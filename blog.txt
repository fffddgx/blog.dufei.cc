-- MySQL dump 10.13  Distrib 5.5.37, for Linux (x86_64)
--
-- Host: localhost    Database: blog
-- ------------------------------------------------------
-- Server version	5.5.37-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `te_comments`
--

DROP TABLE IF EXISTS `te_comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `te_comments` (
  `coid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `cid` int(10) unsigned DEFAULT '0',
  `created` int(10) unsigned DEFAULT '0',
  `author` varchar(200) DEFAULT NULL,
  `authorId` int(10) unsigned DEFAULT '0',
  `ownerId` int(10) unsigned DEFAULT '0',
  `mail` varchar(200) DEFAULT NULL,
  `url` varchar(200) DEFAULT NULL,
  `ip` varchar(64) DEFAULT NULL,
  `agent` varchar(200) DEFAULT NULL,
  `text` text,
  `type` varchar(16) DEFAULT 'comment',
  `status` varchar(16) DEFAULT 'approved',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`coid`),
  KEY `cid` (`cid`),
  KEY `created` (`created`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `te_comments`
--

LOCK TABLES `te_comments` WRITE;
/*!40000 ALTER TABLE `te_comments` DISABLE KEYS */;
/*!40000 ALTER TABLE `te_comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `te_contents`
--

DROP TABLE IF EXISTS `te_contents`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `te_contents` (
  `cid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `modified` int(10) unsigned DEFAULT '0',
  `text` text,
  `order` int(10) unsigned DEFAULT '0',
  `authorId` int(10) unsigned DEFAULT '0',
  `template` varchar(32) DEFAULT NULL,
  `type` varchar(16) DEFAULT 'post',
  `status` varchar(16) DEFAULT 'publish',
  `password` varchar(32) DEFAULT NULL,
  `commentsNum` int(10) unsigned DEFAULT '0',
  `allowComment` char(1) DEFAULT '0',
  `allowPing` char(1) DEFAULT '0',
  `allowFeed` char(1) DEFAULT '0',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`cid`),
  UNIQUE KEY `slug` (`slug`),
  KEY `created` (`created`)
) ENGINE=MyISAM AUTO_INCREMENT=209 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `te_contents`
--

LOCK TABLES `te_contents` WRITE;
/*!40000 ALTER TABLE `te_contents` DISABLE KEYS */;
INSERT INTO `te_contents` VALUES (4,'php-fpm子进程重启设置(pm.max_requests)','4',1425104820,1425275909,'<!--markdown-->php中有很多模块，进程运行时间久了就会有可能出现内存泄露的情况。为了防止内存泄露导致系统内存耗尽，性能变差apache的servers.conf中有个MaxRequestsPerChild配置用来重启httpd子进程。MaxRequestsPerChild指的是每个httpd进程最多服务的次数，大于了这个次数，该子进程就自动退出。如果有必要父进程会重新创建新的httpd子进程来服务。\r\nphp-fpm同样拥有这么一个配置参数，那就是：pm.max_requests\r\n\r\n    ; The number of requests each child process should execute before respawning.\r\n    ; This can be useful to work around memory leaks in 3rd party libraries. For\r\n    ; endless request processing specify \'0\'. Equivalent to PHP_FCGI_MAX_REQUESTS.\r\n    ; Default Value: 0\r\n    ;pm.max_requests = 500\r\n\r\n该参数默认为不限制最大服务次数，也就是子进程永远不重启，经验表明，长时间不重启子进程会导致系统负载异常，处理时间变长等问题。重启后会有明显改善。\r\n更详细的php-fpm配置见：[php-fpm配置][1]\r\n\r\n\r\n  [1]: http://blog.justoffline.com/index.php/archives/10/',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(2,'关于','start-page',1425088980,1448342177,'<!--markdown-->奇虎360服务端开发工程师\r\n\r\n有热爱学习的想法\r\n有关注新技术的意愿\r\n有扯淡的天赋',2,1,NULL,'page','publish',NULL,0,'0','0','1',0),(3,'如何拥有这么一个blog','3',1425103106,1425103106,'<!--markdown-->1、购买一台云主机。我采用的是阿里云的云主机\r\n2、购买一个域名，并备案，然后将域名的dns解析映射到你的云主机上\r\n3、安装lnmp\r\n4、通过运行 \r\n\r\n    .vhost.sh\r\n创建一个server\r\n5、修改你的server.conf支持pathinfo\r\n6、下载typecho，并解压到你的工程目录下\r\n7、在浏览器运行：http://yoururl，配置安装你的typecho\r\n完成。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(5,'2014年结','5',1425105840,1425106897,'<!--markdown--><h2><span style=\"color:#b22222;\">2014年大事列表</span></h2>\r\n<h3><span style=\"color:#b22222;\">做成的</span></h3>\r\n<span style=\"color:#808080;\"><ul><li><span style=\"color:#000000;line-height:1.5;font-weight:bold;\">订婚</span><span style=\"color:#000000;line-height:1.5;\">：谢谢你亲爱的，你是我2014最浓墨重彩的一笔。你超乎一般女生的理性、时刻帮助我理清思路，让我可以享受这么多的任性。 &nbsp;</span></li>\r\n<li><span style=\"color:#000000;line-height:1.5;font-weight:bold;\">拿到驾照</span><span style=\"color:#000000;line-height:1.5;\">：真的不容易，折腾死人。 &nbsp;</span></li>\r\n<li><span style=\"color:#000000;line-height:1.5;font-weight:bold;\">独自开发了一个高并发go系统</span><span style=\"color:#000000;line-height:1.5;\">：谢谢老杨给我了这么一个机会。 &nbsp;</span></li>\r\n<li><span style=\"color:#000000;line-height:1.5;font-weight:bold;\">对php内核在老杨的监督下过了一遍</span><span style=\"color:#000000;line-height:1.5;\">：好勉强，还有一些细节没有完全搞清楚。 &nbsp;</span></li>\r\n<li><span style=\"color:#000000;line-height:1.5;font-weight:bold;\">清明苏杭游</span><span style=\"color:#000000;line-height:1.5;\">：以后不能抱团旅游。 &nbsp;</span></li>\r\n<li><span style=\"color:#000000;line-height:1.5;font-weight:bold;\">游泳初步入门 </span><span style=\"color:#000000;line-height:1.5;\">：初步有了一些水性，还需要继续练习。&nbsp;</span></li>\r\n</ul>\r\n</span> <br />\r\n<h3><span style=\"color:#b22222;\">失去的</span></h3>\r\n<span style=\"color:#808080;\"><ul><li><span style=\"color:#000000;line-height:1.5;font-weight:bold;\">健康指数下降</span><span style=\"color:#000000;line-height:1.5;\">：上厕蹲到脚麻，熬夜困到心慌，早上睡到梦乱，吃饭足到后悔。4个字：任性放纵。健康就是任性，年轻就是放纵！我操。甲状腺结节，高血压，高血脂，怀疑心脏都不好了。我操。 &nbsp;</span></li>\r\n<li><span style=\"color:#000000;line-height:1.5;font-weight:bold;\">学习黄金期浪费了一年</span><span style=\"color:#000000;line-height:1.5;\">：2013年我算入门，2014年我应小有所成。2013我做的还算好。2014年或许是给360还债。业余学习基本荒废。工作太累可以是借口，这，不足以推干净责任，好吧，我承认，我懒惰。 &nbsp;</span></li>\r\n</ul>\r\n</span> <h3><span style=\"color:#b22222;\">没做成的&nbsp;</span></h3>\r\n<span style=\"color:#808080;\"><ul><li><span style=\"color:#000000;line-height:1.5;font-weight:bold;\">想看没有看的书</span><span style=\"color:#000000;line-height:1.5;\">：《深入理解nginx》、《mongodb权威指南》、《linux私房菜》、《高效能认识的七个习惯》、《投资最重要的事儿》等等。。 &nbsp;</span></li>\r\n<li><span style=\"color:#000000;line-height:1.5;font-weight:bold;\">想做没做成的系统</span><span style=\"color:#000000;line-height:1.5;\">：我们约会吧微信服务号，暴走拖延症微信服务号，blog系统，dataserver go版，音乐android &nbsp;</span></li>\r\n</ul>\r\n</span> <br />\r\n2014年可圈可点的成就真的很少，大部分工作时间都是在处理散碎的事情，是一个卖时间的状态。&nbsp;&nbsp;<br />\r\n业余时间1/4的时间在睡觉，1/4时间在看游戏视频，1/4的时间在处理其它琐事，只有剩下的1/4的时间在做有意义的业余活动：运动、学习、陪媳妇。太多想做确没有做的事情。说多了都是泪。&nbsp;&nbsp;<br />\r\n<span style=\"font-weight:bold;\">如果要给14年打分的话，50分，不及格。</span>&nbsp;<br />\r\n<h2><span style=\"color:#b22222;\">15年计划</span></h2>\r\n说来惭愧，真心不敢再说什么鸿鹄之志。我定个最低要求吧，诚惶诚恐，我尽量完成。&nbsp;&nbsp;<br />\r\n<ul><li><span style=\"line-height:1.5;font-weight:bold;\">工作</span><span style=\"line-height:1.5;\">：把dataserver写出来，跳槽到30w，最好是创业公司 &nbsp;</span></li>\r\n<li><span style=\"line-height:1.5;font-weight:bold;\">技术</span><span style=\"line-height:1.5;\">：&nbsp;&nbsp;php内核搞清楚，go语言确定好框架，mongo机制搞清楚，memcache机制搞清楚，redis机制搞清楚，nginx机制搞清楚，linux搞清楚。 &nbsp;</span></li>\r\n<li><span style=\"line-height:1.5;font-weight:bold;\">生活</span><span style=\"line-height:1.5;\">：控制在155以下，最好能减到150。一周保持运动3次以上，每次1个小时以上。一周不能超过2次12点半以后睡觉。 &nbsp;</span></li>\r\n<li><span style=\"line-height:1.5;font-weight:bold;\">爱情</span><span style=\"line-height:1.5;\">：结婚不敢想，我希望15年能打好基础，16年能结婚。 &nbsp;</span></li>\r\n</ul>\r\n加油吧!<br />\r\n<br />\r\n<br />\r\n<br />',0,1,NULL,'post','private',NULL,0,'1','1','1',0),(11,'centos下编译安装nodejs','11',1425351480,1425351593,'<!--markdown-->1、下载源码，你需要在http://nodejs.org/下载最新的Nodejs版本，本文以v0.10.24为例:\r\n\r\n    wget http://nodejs.org/dist/v0.10.24/node-v0.10.24.tar.gz\r\n\r\n2、解压源码\r\n\r\n    tar zxvf node-v0.10.24.tar.gz\r\n\r\n3、 编译安装\r\n\r\n    cd node-v0.10.24\r\n    ./configure --prefix=/usr/local/node/0.10.24\r\n    make\r\n    make install\r\n\r\n4、 配置NODE_HOME，进入profile编辑环境变量\r\n\r\n    vim /etc/profile\r\n\r\n设置nodejs环境变量，在export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL 一行的上面添加如下内容:\r\n\r\n    #set for nodejs\r\n    export NODE_HOME=/usr/local/node/0.10.24\r\n    export PATH=$NODE_HOME/bin:$PATH\r\n\r\n:wq保存并退出，编译/etc/profile 使配置生效\r\n\r\n    source /etc/profile\r\n\r\n验证是否安装配置成功\r\n\r\n    node -v\r\n\r\n输出 v0.10.24 表示配置成功\r\n\r\nnpm模块安装路径\r\n\r\n    /usr/local/node/0.10.24/lib/node_modules/\r\n\r\n注：Nodejs 官网提供了编译好的Linux二进制包，你也可以下载下来直接应用。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(12,'5年后想成为什么样的人?','12',1425614220,1432539931,'<!--markdown-->5年后，2020年，33岁。我想成为什么样的人呢？有个家有个孩子，一份自己的事业，一个健康的身体。\r\n### 一份自己的事业 ###\r\n5年后我想有自己的一个公司，或者说起码占有一定股份的公司。这个公司差点可以让我衣食无忧，好点让我财务自由。\r\n为了达到这个目标：\r\n\r\n - 4年后（2019）我应该已经创建或者加入了这个公司，已经有主力的员工和合作伙伴\r\n - 3年后（2018）我起码自己主持设计了一个大系统，日访问量起码过亿。对整个技术架构有个详细了解。设计、开发、日志、调试、备份、容灾、监控、统计等都有一整套的方案。服务端可以独挡一面,有经验、有人脉、有技术、有管理。\r\n - 2年后（2017）我应该参与设计过一个大系统，不是主要设计人，也应该是个次要设计人。\r\n - 1年后（2016）我应该经历过2-3个这种大系统，对这种别人设计的大系统有个整体的认识，自己参与对系统进行开发，改进，优化，对比。\r\n - 现在我要努力把自己的基础打好，对现有系统做个梳理，跳到一个可以让我实现1年后目标的地方。这个地方产品有量，技术有大牛。是牛人特别多的大公司，或者金牌创业团队。',0,1,NULL,'post','private',NULL,0,'0','0','0',0),(13,'PHP内核SAPI之PHP-FPM','13',1425637320,1425981395,'<!--markdown-->sapi（server abstraction api）是外界跟php内核通信的接口。改接口定义了外界跟php通信的规则。php跟外界通信又包括很多种手段，比如命令行手段，直接输入 php abx.php，就可以执行php文件。当今比较重要的集中sapi实现包括：cli（命令行），mode_php5(apache跟php通信的模块)，php-fpm(实现了fastcgi协议的sapi)。这里主要讲解php-fpm是如何实现sapi的。\r\nphp-fpm入口：sapi/fpm/fpm-main.c的main函数。启动php-fpm后，它会监听一个tcp端口，根据配置启动1个主进程，多个子进程。其中主进程主要进行对子进程的管理守护，子进程复杂处理php请求。\r\n从**main**函数看起\r\n\r\n        int main(int argc, char *argv[])\r\n        {\r\n                .......\r\n        \r\n        	sapi_startup(&cgi_sapi_module);\r\n                .......\r\n        	fcgi_init();\r\n                .......\r\n    \r\n其中sapi_startup在MAIN/SAPI.C文件中，主要做所有sapi都需要的初始化工作。这里像sapi_startup传递了**cgi_sapi_module**这个变量，该变量定义了一个sapi实现。php-fpm的实现如下：\r\n    \r\n    struct _sapi_module_struct {\r\n    	char *name;\r\n    	char *pretty_name;\r\n    \r\n    	int (*startup)(struct _sapi_module_struct *sapi_module);\r\n    	int (*shutdown)(struct _sapi_module_struct *sapi_module);\r\n    \r\n    	int (*activate)(TSRMLS_D);\r\n    	int (*deactivate)(TSRMLS_D);\r\n    \r\n    	int (*ub_write)(const char *str, unsigned int str_length TSRMLS_DC);\r\n    	void (*flush)(void *server_context);\r\n    	struct stat *(*get_stat)(TSRMLS_D);\r\n    	char *(*getenv)(char *name, size_t name_len TSRMLS_DC);\r\n    \r\n    	void (*sapi_error)(int type, const char *error_msg, ...);\r\n    \r\n    	int (*header_handler)(sapi_header_struct *sapi_header, sapi_header_op_enum op, sapi_headers_struct *sapi_headers TSRMLS_DC);\r\n    	int (*send_headers)(sapi_headers_struct *sapi_headers TSRMLS_DC);\r\n    	void (*send_header)(sapi_header_struct *sapi_header, void *server_context TSRMLS_DC);\r\n    \r\n    	int (*read_post)(char *buffer, uint count_bytes TSRMLS_DC);\r\n    	char *(*read_cookies)(TSRMLS_D);\r\n    \r\n    	void (*register_server_variables)(zval *track_vars_array TSRMLS_DC);\r\n    	void (*log_message)(char *message TSRMLS_DC);\r\n    	double (*get_request_time)(TSRMLS_D);\r\n    	void (*terminate_process)(TSRMLS_D);\r\n    \r\n    	char *php_ini_path_override;\r\n    \r\n    	void (*block_interruptions)(void);\r\n    	void (*unblock_interruptions)(void);\r\n    \r\n    	void (*default_post_reader)(TSRMLS_D);\r\n    	void (*treat_data)(int arg, char *str, zval *destArray TSRMLS_DC);\r\n    	char *executable_location;\r\n    \r\n    	int php_ini_ignore;\r\n    	int php_ini_ignore_cwd; /* don\'t look for php.ini in the current directory */\r\n    \r\n    	int (*get_fd)(int *fd TSRMLS_DC);\r\n    \r\n    	int (*force_http_10)(TSRMLS_D);\r\n    \r\n    	int (*get_target_uid)(uid_t * TSRMLS_DC);\r\n    	int (*get_target_gid)(gid_t * TSRMLS_DC);\r\n    \r\n    	unsigned int (*input_filter)(int arg, char *var, char **val, unsigned int val_len, unsigned int *new_val_len TSRMLS_DC);\r\n    	\r\n    	void (*ini_defaults)(HashTable *configuration_hash);\r\n    	int phpinfo_as_text;\r\n    \r\n    	char *ini_entries;\r\n    	const zend_function_entry *additional_functions;\r\n    	unsigned int (*input_filter_init)(TSRMLS_D);\r\n    };\r\n\r\n该结构体定义了php-fpm的一些属性和处理函数。相当于一个配置注册文件。里面注册了php-fpm的名字（调用phpinfo（）的时候就会出现这个名字），启动函数，关闭函数，服务函数，关闭服务函数写缓存函数，读取系统环境变量函数，log函数等等。\r\n**sapi_startup**里面主要调用了**sapi_globals_ctor**,**sapi_globals_ctor**主要是初始化了sapi的全局参数。这里涉及一个struct :**sapi_globals_struct**   \r\n\r\n    typedef struct _sapi_globals_struct {\r\n    	void *server_context;\r\n    	sapi_request_info request_info;\r\n    	sapi_headers_struct sapi_headers;\r\n    	int read_post_bytes;\r\n    	unsigned char headers_sent;\r\n    	struct stat global_stat;\r\n    	char *default_mimetype;\r\n    	char *default_charset;\r\n    	HashTable *rfc1867_uploaded_files;\r\n    	long post_max_size;\r\n    	int options;\r\n    	zend_bool sapi_started;\r\n    	double global_request_time;\r\n    	HashTable known_post_content_types;\r\n    	zval *callback_func;\r\n    	zend_fcall_info_cache fci_cache;\r\n    	zend_bool callback_run;\r\n    } sapi_globals_struct;\r\n\r\n该结构体是全局变量保存了请求的基本信息。sapi_globals_ctor为该全局变量申请空间并对初始化known_post_content_types。\r\n回到main函数，接下来会执行**fcgi_init();**，',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(14,'笔迹','14',1425711060,1425711949,'<!--markdown-->',1,1,'page-archive.php','page','publish',NULL,0,'0','0','0',0),(15,'通俗说EPOLL','15',1425744480,1425975110,'<!--markdown-->首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。不管是文件，还是套接字，还是管道，我们都可以把他们看作流。\r\n\r\n之后我们来讨论I/O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假定一个情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是服务器还没有把数据传回来），这时候该怎么办？\r\n\r\n**阻塞**：阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。\r\n\r\n**非阻塞忙轮询**：接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：“你到了没？”\r\n\r\n很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。\r\n\r\n为了了解阻塞是如何进行的，我们来讨论**缓冲区**，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。\r\n\r\n假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。\r\n\r\n假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。\r\n但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。\r\n\r\n假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”\r\n也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。\r\n\r\n这四个情形涵盖了四个I/O事件，**缓冲区满，缓冲区空，缓冲区非空，缓冲区非满**（注都是说的内核缓冲区，且这四个术语都是我生造的，仅为解释其原理而造）。这四个I/O事件是进行阻塞同步的根本。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。\r\n\r\n然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。\r\n于是再来考虑非阻塞忙轮询的I/O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）：\r\n\r\n    while true {\r\n        for i in stream[]; {\r\n            if i has data\r\n            read until unavailable\r\n        }\r\n    }\r\n我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会**白白浪费CPU**。这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。\r\n\r\n**为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）**。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）。代码长这样:\r\n\r\n    while true {\r\n        select(streams[])\r\n        for i in streams[] {\r\n            if i has data\r\n            read until unavailable\r\n        }\r\n    }\r\n\r\n于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。\r\n但是使用select，我们有**O(n)**的无差别轮询复杂度，同时处理的流越多，没一次无差别轮询时间就越长。再次\r\n说了这么多，终于能好好解释epoll了\r\nepoll可以理解为event poll，不同于忙轮询和无差别轮询，**epoll知道那个流发生了事件，会把那个流发生了怎样的I/O事件通知我们**。此时我们对这些流的操作都是有意义的。（复杂度降低到了**O(k)**，k为产生I/O事件的流的个数）。\r\n等等，epoll是怎么知道哪个流发生了事件呢？这里我们要看2个数据结构\r\n\r\n        typedef union epoll_data {\r\n                        void *ptr;\r\n                        int fd;\r\n                        __uint32_t u32;\r\n                        __uint64_t u64;\r\n        } epoll_data_t;\r\n    \r\n       struct epoll_event {\r\n                    __uint32_t events;      /* Epoll events */\r\n                    epoll_data_t data;      /* User data variable */\r\n        }; \r\n\r\n可以看到,epoll_data是一个union结构体,它就是epoll事件信息的结构体,它可以保存很多类型的信息:fd,指针,等等.有了这个结构体,epoll就可以定位到这个流事件该由谁处理了。\r\n\r\n在讨论epoll的实现细节之前，先把epoll的相关操作列出：\r\n\r\n    epoll_create //创建一个epoll对象，一般epollfd = epoll_create()\r\n    \r\n    epoll_ctl //（epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件\r\n    //比如\r\n    epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);//注册缓冲区非空事件，即有数据流入\r\n    epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);//注册缓冲区非满事件，即流可以被写入\r\n    epoll_wait(epollfd,...)//等待直到注册的事件发生\r\n\r\n（注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回-1，并设置errno=EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件）。\r\n\r\n一个epoll模式的代码大概的样子是：\r\n\r\n    while true {\r\n        active_stream[] = epoll_wait(epollfd)\r\n        for i in active_stream[] {\r\n            read or write till\r\n        }\r\n    }\r\n\r\n总体来说：linux下的网卡driver都是在有数据时，通过接口通知os。os为节省资源，关中断后，从driver buffer狂读数据。然后，把处理给协议栈处理，拿tcp为例，当在某些状态点时，会去wakeup相应的sock->socket_wq。socket_wq是一个套接字的等待队列，wakeup的操作，就是执行挂在这个wq上的eppoll_entry的callback。这个callback就是把自己对应的epoll对象epitem挂到epollevent的readylist上。\r\n\r\n此时，如果你调用了epoll_wait()，那就直接从epollevent的readylist上，把event复制给你就完了。\r\n\r\n简单的说，就是一个生产者，消费者的方式。底层生成数据，放到readylist，用户用epoll_wait去取。\r\n限于篇幅，我只说这么多，以揭示原理性的东西，至于epoll的使用细节，请参考man和google，实现细节，请参阅linux kernel source。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(18,'linux进程通信之信号','18',1425970440,1426656475,'<!--markdown-->信号是UNIX和Linux系统响应某些条件而产生的一个事件，接收到该信号的进程会相应地采取一些行动。通常信号是由一个错误产生的。但它们还可以作为进程间通信或修改行为的一种方式，明确地由一个进程发送给另一个进程。一个信号的产生叫生成，接收到一个信号叫捕获。\r\n\r\n\r\n<!--more-->\r\n\r\n我们已经知道，我们可以通过信号来终止进程，也可以通过信号来在进程间进行通信，程序也可以通过指定信号的关联处理函数来改变信号的默认处理方式，也可以屏蔽某些信号。那么我们应该如何设定我们需要处理的信号，我们不需要处理哪些信号等问题呢？信号集函数就是帮助我们解决这些问题的。\r\n\r\n - 1、int sigemptyset(sigset_t *set); 该函数的作用是将信号集初始化为空。\r\n - 2、int sigfillset(sigset_t *set); 该函数的作用是把信号集初始化包含所有已定义的信号。\r\n - 3、int sigaddset(sigset_t *set, int signo); 该函数的作用是把信号signo添加到信号集set中，成功时返回0，失败时返回-1。\r\n - 4、int sigdelset(sigset_t *set, int signo);该函数的作用是把信号signo从信号集set中删除，成功时返回0，失败时返回-1.\r\n - 5、int sigismember(sigset_t *set, int signo);该函数的作用是判断给定的信号signo是否是信号集中的一个成员，如果是返回1，如果不是，返回0，如果给定的信号无效，返回-1；\r\n - 6、int sigpromask(int how, const sigset_t *set, sigset_t *oset);该函数可以根据参数指定的方法修改进程的信号屏蔽字。\r\n - 7、int sigpending(sigset_t  *set);该函数的作用是将被阻塞的信号中停留在待处理状态的一组信号写到参数set指向的信号集中，成功调用返回0，否则返回-1，并设置errno表明错误原因\r\n - 8、int sigsuspend(const sigset_t *sigmask);  该函数通过将进程的屏蔽字替换为由参数sigmask给出的信号集，然后挂起进程的执行。注意操作的先后顺序，是先替换再挂起程序的执行。程序将在信号处理函数执行完毕后继续执行。如果接收到信号终止了程序，sigsuspend就不会返回，如果接收到的信号没有终止程序，sigsuspend就返回-1，并将errno设置为EINTR。\r\n\r\n**示例：**\r\n\r\n    #include <unistd.h>\r\n    #include <signal.h>\r\n    #include <sys/types.h>\r\n    #include <stdlib.h>\r\n    #include <stdio.h>\r\n    void handler(int sig)\r\n    {\r\n    	printf(\"Handle the signal %d\\n\", sig);\r\n    }\r\n    \r\n    int main()\r\n    {\r\n    	sigset_t sigset;//用于记录屏蔽字\r\n    	sigset_t ign;//用于记录被阻塞的信号集\r\n    	struct sigaction act;\r\n    	//清空信号集\r\n    	sigemptyset(&sigset);\r\n    	sigemptyset(&ign);\r\n    	//向信号集中添加信号SIGINT\r\n    	sigaddset(&sigset, SIGINT);\r\n    \r\n    	//设置处理函数和信号集	\r\n    	act.sa_handler = handler;\r\n    	sigemptyset(&act.sa_mask);\r\n    	act.sa_flags = 0;\r\n    	sigaction(SIGINT, &act, 0);\r\n    \r\n    	printf(\"Wait the signal SIGINT...\\n\");\r\n    	pause();//挂起进程，等待信号\r\n    \r\n    	//设置进程屏蔽字，在本例中为屏蔽SIGINT	\r\n    	sigprocmask(SIG_SETMASK, &sigset, 0);	\r\n    	printf(\"Please press Ctrl+c in 10 seconds...\\n\");\r\n    	sleep(10);\r\n    	//测试SIGINT是否被屏蔽\r\n    	sigpending(&ign);\r\n    	if(sigismember(&ign, SIGINT))\r\n    		printf(\"The SIGINT signal has ignored\\n\");\r\n    	//在信号集中删除信号SIGINT\r\n    	sigdelset(&sigset, SIGINT);\r\n    	printf(\"Wait the signal SIGINT...\\n\");\r\n    	//将进程的屏蔽字重新设置，即取消对SIGINT的屏蔽\r\n    	//并挂起进程\r\n    	sigsuspend(&sigset);\r\n    \r\n    	printf(\"The app will exit in 5 seconds!\\n\");\r\n    	sleep(5);\r\n    	exit(0);\r\n    }\r\n\r\n在终端使用**kill -l** 命令可以显示所有的信号。\r\n\r\n    SIGHUP 1　　　 　A　　终端挂起或者控制进程终止\r\n    SIGINT 2　　　 　A　　键盘中断（如break键被按下）\r\n    SIGQUIT 3　　 　 C　　键盘的退出键被按下\r\n    SIGILL 4　　 　　C　　非法指令\r\n    SIGABRT 6　　　　 C　　由abort(3)发出的退出指令\r\n    SIGFPE 8　　　　 C　　浮点异常\r\n    SIGKILL 9　　 　 AEF　 Kill信号\r\n    SIGSEGV 11　　 　 C　　无效的内存引用\r\n    SIGPIPE 13　　 　 A　　管道破裂: 写一个没有读端口的管道\r\n    SIGALRM 14　　　 A　　由alarm(2)发出的信号\r\n    SIGTERM 15　　　 A　　终止信号\r\n    SIGUSR1 30,10,16 A　　用户自定义信号1\r\n    SIGUSR2 31,12,17 A　　用户自定义信号2\r\n    SIGCHLD 20,17,18 B　　子进程结束信号\r\n    SIGCONT 19,18,25 　　　进程继续（曾被停止的进程）\r\n    SIGSTOP 17,19,23 DEF　终止进程\r\n    SIGTSTP 18,20,24 D　　控制终端（tty）上按下停止键\r\n    SIGTTIN 21,21,26 D　　后台进程企图从控制终端读\r\n    SIGTTOU 22,22,27 D　　后台进程企图从控制终端写',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(19,'PHP及Zend Engine的线程安全模型','19',1425974640,1425975130,'<!--markdown-->php多线程\r\n------\r\n\r\nPHP 5.3 以上版本，使用pthreads PHP扩展，可以使PHP真正地支持多线程。多线程在处理重复性的循环任务，能够大大缩短程序执行时间。\r\n\r\n如果用 MySQL 数据库，一条联合查询的SQL，也许就可以处理完业务逻辑，但是，遇到大量并发请求，就歇菜了。如果用 NoSQL 数据库，也许需要十次查询，才能处理完同样地业务逻辑，但每次查询都比 MySQL 要快，十次循环NoSQL查询也许比一次MySQL联合查询更快，应对几万次/秒的查询完全没问题。如果加上PHP多线程，通过十个线程同时查询NoSQL，返回结果汇总输出，速度就要更快了。\r\n\r\n\r\n\r\n线程安全\r\n----\r\n线程安全问题，一言以蔽之就是多线程环境下如何安全存取公共资源。我们知道，每个线程只拥有一个私有栈，共享所属进程的堆。在C中，当一个变量被声明在任何函数之外时，就成为一个全局变量，这时这个变量会被分配到进程的共享存储空间，不同线程都引用同一个地址空间，因此一个线程如果修改了这个变量，就会影响到全部线程。这看似为线程共享数据提供了便利，但是PHP往往是每个线程处理一个请求，因此希望每个线程拥有一个全局变量的副本，而不希望请求间相互干扰。\r\n\r\n早期的PHP往往用于单线程环境，每个进程只启动一个线程，因此不存在线程安全问题。后来出现了多线程环境下使用PHP的场景，因此Zend引入了Zend线程安全机制（Zend Thread Safety，简称ZTS）用于保证线程的安全。\r\n\r\n说起来ZTS的基本思想是很直观的，不是就是需要每个全局变量在每个线程都拥有一个副本吗？那我就提供这样的机制：\r\n\r\n在多线程环境下，申请全局变量不再是简单声明一个变量，而是整个进程在堆上分配一块内存空间用作“线程全局变量池”，在进程启动时初始化这个内存池，每当有线程需要申请全局变量时，通过相应方法调用TSRM（Thread Safe Resource Manager，ZTS的具体实现）并传递必要的参数（如变量大小等等），TSRM负责在内存池中分配相应内存区块并将这块内存的引用标识返回，这样下次这个线程需要读写此变量时，就可以通过将唯一的引用标识传递给TSRM，TSRM将负责真正的读写操作。这样就实现了线程安全的全局变量。下图给出了ZTS原理的示意图：\r\n                ![ZTS原理的示意图][1]\r\n\r\n\r\nThread1和Thread2同属一个进程，其中各自需要一个全局变量Global Var，TSRM为两者在线程全局内存池中（黄色部分）各自分配了一个区域，并且通过唯一的ID进行标识，这样两个线程就可以通过TSRM存取自己的变量而互不干扰。\r\n\r\n**在多线程模式中，PHP的生命周期如下**：\r\n![多线程模式中，PHP的生命周期][2]\r\n\r\n\r\n进程启动后，在MINIT阶段启动TSRM（通过sapi调用tsrm_startup），然后在遍历模块时调用每一个模块的MINIT方法，模块在MINIT中告知TSRM要申请多少全局变量及大小（通过ts_allocate_id），TSRM在内存池中分配并做好登记工作（tsrm_tls_table和resource_types_table），然后将凭证（资源ID）返回给模块，告诉模块以后拿着这个凭证来取你的全局变量。\r\n\r\n参考文献：\r\n[深入研究PHP及Zend Engine的线程安全模型][3]\r\n[PHP 真正多线程的使用][4]\r\n\r\n\r\n  [1]: http://7vzu8r.com1.z0.glb.clouddn.com/1.png\r\n  [2]: http://7vzu8r.com1.z0.glb.clouddn.com/4.png\r\n  [3]: http://blog.codinglabs.org/articles/zend-thread-safety.html\r\n  [4]: http://zyan.cc/pthreads/',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(20,'linux进程通信之管道','20',1426055640,1426061962,'<!--markdown-->管道的定义\r\n=====\r\n\r\n如果你使用过Linux的命令，那么对于管道这个名词你一定不会感觉到陌生，因为我们通常通过符号“|\"来使用管道，但是管理的真正定义是什么呢？管道是一个进程连接数据流到另一个进程的通道，它通常是用作把一个进程的输出通过管道连接到另一个进程的输入。\r\n\r\n举个例子，在shell中输入命令：ls -l | grep string，我们知道ls命令（其实也是一个进程）会把当前目录中的文件都列出来，但是它不会直接输出，而是把本来要输出到屏幕上的数据通过管道输出到grep这个进程中，作为grep这个进程的输入，然后这个进程对输入的信息进行筛选，把存在string的信息的字符串（以行为单位）打印在屏幕上。\r\n\r\n管道分为2种，一种是**匿名管道**\r\n没有名字，创建完只知道管道的两头：fd 0 读端、fd 1 写端，只有自己的儿子和亲戚才能知道这个管道，也就是非兄弟进程，子进程是不能通过这种管道通信的\r\n一种是**非匿名管道**\r\n也就是有名字的管道，大家都可以通过名字找到它。\r\n\r\n实现原理\r\n====\r\n\r\n在Linux中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现为：\r\n限制管道的大小。实际上，管道是一个固定大小的缓冲区。在Linux中，该缓冲区的大小为1页，即4K字节，使得它的大小不象文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，当这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用写。\r\n读取进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题。\r\n注意：从管道读数据是一次性操作，数据一旦被读，它就从管道中被抛弃，释放空间以便写更多的数据。\r\n\r\n管道的结构\r\n-----\r\n\r\n在 Linux 中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个 file 结构指向同一个临时的 VFS 索引节点，而这个 VFS 索引节点又指向一个物理页面而实现的。如下图所示：\r\n![管道结构示意图][1]\r\n\r\n图7.1中有两个 file 数据结构，但它们定义文件操作例程地址是不同的，其中一个是向管道中写入数据的例程地址，而另一个是从管道中读出数据的例程地址。这样，用户程序的系统调用仍然是通常的文件操作，而内核却利用这种**抽象机制**实现了管道这一特殊操作。\r\n\r\n管道的读写\r\n-----\r\n\r\n管道实现的源代码在fs/pipe.c中，在pipe.c中有很多函数，其中有两个函数比较重要，即管道读函数pipe_read()和管道写函数pipe_wrtie()。管道写函数通过将字节复制到 VFS 索引节点指向的物理内存而写入数据，而管道读函数则通过复制物理内存中的字节而读出数据。当然，内核必须利用一定的机制同步对管道的访问，为此，内核使用了锁、等待队列和信号。\r\n当写进程向管道中写入时，它利用标准的库函数write()，系统根据库函数传递的文件描述符，可找到该文件的 file 结构。file 结构中指定了用来进行写操作的函数（即写入函数）地址，于是，内核调用该函数完成写操作。写入函数在向内存中写入数据之前，必须首先检查 VFS 索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作：\r\n \r\n\r\n - 内存中有足够的空间可容纳所有要写入的数据；\r\n - 内存没有被读程序锁定。\r\n\r\n \r\n如果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。否则，写入进程就休眠在 VFS 索引节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写入数据，或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。\r\n管道的读取过程和写入过程类似。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖于文件或管道的打开模式。反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放。\r\n\r\n\r\n示例\r\n==\r\n 匿名管道示例：\r\n\r\n    /**************\r\n     * readtest.c *\r\n     **************/\r\n    #include <unistd.h>\r\n    #include <sys/types.h>\r\n    #include <errno.h>\r\n    main()\r\n    {\r\n    	int pipe_fd[2];\r\n    	pid_t pid;\r\n    	char r_buf[100];\r\n    	char w_buf[4];\r\n    	char* p_wbuf;\r\n    	int r_num;\r\n    	int cmd;\r\n    	\r\n    	memset(r_buf,0,sizeof(r_buf));\r\n    	memset(w_buf,0,sizeof(r_buf));\r\n    	p_wbuf=w_buf;\r\n    	if(pipe(pipe_fd)<0)\r\n    	{\r\n    		printf(\"pipe create error\\n\");\r\n    		return -1;\r\n    	}\r\n    	\r\n    	if((pid=fork())==0)\r\n    	{\r\n    		printf(\"\\n\");\r\n    		close(pipe_fd[1]);\r\n    		sleep(3);//确保父进程关闭写端\r\n    	    r_num=read(pipe_fd[0],r_buf,100);\r\n    printf(	\"read num is %d   the data read from the pipe is %d\\n\",r_num,atoi(r_buf));\r\n    		\r\n    		close(pipe_fd[0]);\r\n    		exit();\r\n    	}\r\n    	else if(pid>0)\r\n    	{\r\n    	close(pipe_fd[0]);//read\r\n    	strcpy(w_buf,\"111\");\r\n    	if(write(pipe_fd[1],w_buf,4)!=-1)\r\n    		printf(\"parent write over\\n\");\r\n    	close(pipe_fd[1]);//write\r\n    		printf(\"parent close fd[1] over\\n\");\r\n    	sleep(10);\r\n    	}	\r\n    }\r\n     /**************************************************\r\n     * 程序输出结果：\r\n     * parent write over\r\n     * parent close fd[1] over\r\n     * read num is 4   the data read from the pipe is 111\r\n     * 附加结论：\r\n     * 管道写端关闭后，写入的数据将一直存在，直到读出为止.\r\n     ****************************************************/\r\n有名管道示例：\r\n程序1：写FIFO程序\r\n\r\n    #include <unistd.h>  \r\n    #include <stdlib.h>  \r\n    #include <fcntl.h>  \r\n    #include <limits.h>  \r\n    #include <sys/types.h>  \r\n    #include <sys/stat.h>  \r\n    #include <stdio.h>  \r\n    #include <string.h>  \r\n      \r\n    int main()  \r\n    {  \r\n        const char *fifo_name = \"/tmp/my_fifo\";  \r\n        int pipe_fd = -1;  \r\n        int data_fd = -1;  \r\n        int res = 0;  \r\n        const int open_mode = O_WRONLY;  \r\n        int bytes_sent = 0;  \r\n        char buffer[PIPE_BUF + 1];  \r\n      \r\n        if(access(fifo_name, F_OK) == -1)  \r\n        {  \r\n            //管道文件不存在  \r\n            //创建命名管道  \r\n            res = mkfifo(fifo_name, 0777);  \r\n            if(res != 0)  \r\n            {  \r\n                fprintf(stderr, \"Could not create fifo %s\\n\", fifo_name);  \r\n                exit(EXIT_FAILURE);  \r\n            }  \r\n        }  \r\n      \r\n        printf(\"Process %d opening FIFO O_WRONLY\\n\", getpid());  \r\n        //以只写阻塞方式打开FIFO文件，以只读方式打开数据文件  \r\n        pipe_fd = open(fifo_name, open_mode);  \r\n        data_fd = open(\"Data.txt\", O_RDONLY);  \r\n        printf(\"Process %d result %d\\n\", getpid(), pipe_fd);  \r\n      \r\n        if(pipe_fd != -1)  \r\n        {  \r\n            int bytes_read = 0;  \r\n            //向数据文件读取数据  \r\n            bytes_read = read(data_fd, buffer, PIPE_BUF);  \r\n            buffer[bytes_read] = \'\\0\';  \r\n            while(bytes_read > 0)  \r\n            {  \r\n                //向FIFO文件写数据  \r\n                res = write(pipe_fd, buffer, bytes_read);  \r\n                if(res == -1)  \r\n                {  \r\n                    fprintf(stderr, \"Write error on pipe\\n\");  \r\n                    exit(EXIT_FAILURE);  \r\n                }  \r\n                //累加写的字节数，并继续读取数据  \r\n                bytes_sent += res;  \r\n                bytes_read = read(data_fd, buffer, PIPE_BUF);  \r\n                buffer[bytes_read] = \'\\0\';  \r\n            }  \r\n            close(pipe_fd);  \r\n            close(data_fd);  \r\n        }  \r\n        else  \r\n            exit(EXIT_FAILURE);  \r\n      \r\n        printf(\"Process %d finished\\n\", getpid());  \r\n        exit(EXIT_SUCCESS);  \r\n    }  \r\n\r\n程序2：读数据\r\n\r\n    #include <unistd.h>  \r\n    #include <stdlib.h>  \r\n    #include <stdio.h>  \r\n    #include <fcntl.h>  \r\n    #include <sys/types.h>  \r\n    #include <sys/stat.h>  \r\n    #include <limits.h>  \r\n    #include <string.h>  \r\n      \r\n    int main()  \r\n    {  \r\n        const char *fifo_name = \"/tmp/my_fifo\";  \r\n        int pipe_fd = -1;  \r\n        int data_fd = -1;  \r\n        int res = 0;  \r\n        int open_mode = O_RDONLY;  \r\n        char buffer[PIPE_BUF + 1];  \r\n        int bytes_read = 0;  \r\n        int bytes_write = 0;  \r\n        //清空缓冲数组  \r\n        memset(buffer, \'\\0\', sizeof(buffer));  \r\n      \r\n        printf(\"Process %d opening FIFO O_RDONLY\\n\", getpid());  \r\n        //以只读阻塞方式打开管道文件，注意与fifowrite.c文件中的FIFO同名  \r\n        pipe_fd = open(fifo_name, open_mode);  \r\n        //以只写方式创建保存数据的文件  \r\n        data_fd = open(\"DataFormFIFO.txt\", O_WRONLY|O_CREAT, 0644);  \r\n        printf(\"Process %d result %d\\n\",getpid(), pipe_fd);  \r\n      \r\n        if(pipe_fd != -1)  \r\n        {  \r\n            do  \r\n            {  \r\n                //读取FIFO中的数据，并把它保存在文件DataFormFIFO.txt文件中  \r\n                res = read(pipe_fd, buffer, PIPE_BUF);  \r\n                bytes_write = write(data_fd, buffer, res);  \r\n                bytes_read += res;  \r\n            }while(res > 0);  \r\n            close(pipe_fd);  \r\n            close(data_fd);  \r\n        }  \r\n        else  \r\n            exit(EXIT_FAILURE);  \r\n      \r\n        printf(\"Process %d finished, %d bytes read\\n\", getpid(), bytes_read);  \r\n        exit(EXIT_SUCCESS);  \r\n    }  \r\n\r\n参考文献：\r\n-----\r\n\r\n[Linux环境进程间通信（一）][2]\r\n[Linux进程间通信——使用命名管道][3]\r\n[进程间通信管道进阶篇：linux下dup/dup2函数的用法][4]\r\n[解惑dup/dup2(原创)][5]\r\n[Linux Programmer\'s Manual][6]\r\n[Linux系统调用之open(), close()][7]\r\n[Linux管道的实现机制][8]\r\n\r\n\r\n  [1]: http://7vzu8r.com1.z0.glb.clouddn.com/%E7%AE%A1%E9%81%93%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.gif\r\n  [2]: http://www.ibm.com/developerworks/cn/linux/l-ipc/part1/\r\n  [3]: http://blog.csdn.net/ljianhui/article/details/10202699\r\n  [4]: http://www.cnblogs.com/GODYCA/archive/2013/01/05/2846197.html\r\n  [5]: http://blog.donews.com/mutecat/archive/2007/09/20/1212178.aspx\r\n  [6]: http://man7.org/linux/man-pages/man2/dup.2.html\r\n  [7]: http://joe.is-programmer.com/posts/17463.html\r\n  [8]: http://oss.org.cn/kernel-book/ch07/7.1.1.htm',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(21,'构建可gdb源码的php-fpm','21',1426069560,1426081433,'<!--markdown-->查看php内核源码，对着代码干看硬看，难免会有看不明白的时候，即使看明白了也不知道你以为你以为得是不是就真是对的。所以这里搭建一个php内核的gdb调试环境，可以随处加断点，查看变量内容等等，非常有利于学习研究php内核。下面进入正题。\r\n\r\n这里采用php-5.6\r\n系统环境：\r\n\r\n    [root@localhost etc]# cat /etc/redhat-release \r\n    CentOS release 6.5 (Final)\r\n\r\n下载 PHP 源码包\r\n\r\n    # wget http://cn2.php.net/distributions/php-5.6.0.tar.xz\r\n    # xz -d php-5.6.0.tar.xz\r\n    # tar xf php-5.6.0.tar \r\n\r\n安装依赖\r\n\r\n    yum install gcc bison bison-devel zlib-devel libmcrypt-devel mcrypt mhash-devel openssl-devel libxml2-devel libcurl-devel bzip2-devel readline-devel libedit-devel sqlite-devel\r\n\r\n创建 www 用户\r\n\r\n    # groupadd www\r\n    # useradd -g www -s /sbin/nologin -M www\r\n\r\n编译安装，这里不添加额外的扩展包，只用来gdb调试源码，学习php内核用。\r\n\r\n    ./configure --enable-fpm --with-fpm-user=www  --with-fpm-group=www --enable-debug --prefix=/usr/local/php/ --with-config-file-path=/usr/local/php/etc\r\n    make\r\n    make install\r\n\r\n配置php-fpm\r\n创建配置文件\r\n\r\n    cd /usr/local/php/etc\r\n    touch php-fpm.conf\r\n    vim php-fpm.conf\r\n\r\n帖入如下配置：\r\n\r\n    [global]\r\n    pid = /usr/local/php/var/run/php-fpm.pid\r\n    error_log = /usr/local/php/var/log/php-fpm.log\r\n    log_level = notice\r\n    \r\n    [www]\r\n    listen = /tmp/php-cgi.sock\r\n    listen.backlog = -1\r\n    listen.allowed_clients = 127.0.0.1\r\n    listen.owner = www\r\n    listen.group = www\r\n    listen.mode = 0666\r\n    user = www\r\n    group = www\r\n    pm = dynamic\r\n    pm.max_children = 10\r\n    pm.start_servers = 1\r\n    pm.min_spare_servers = 1\r\n    pm.max_spare_servers = 6\r\n    request_terminate_timeout = 100\r\n    request_slowlog_timeout = 0\r\n    slowlog = var/log/slow.log\r\n\r\n具体配置信息，可以查看[php-fpm配置][1]。其中值得一说的是将pm.start_servers 设置成了1，这样就直接attach一个子进程就可以了。如果多个，一个请求不一定就被attach的进程捕获到。\r\n\r\n    cp ~/down/php-5.6.0/sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm\r\n    chmod +x /etc/init.d/php-fpm\r\n\r\n其中~/down/php-5.6.0是源码的目录。\r\n启动php-fpm\r\n\r\n    service php-fpm start\r\n\r\n查看是否启动成功：\r\n\r\n    [root@localhost etc]# ps axu | grep fpm\r\n    root      62822  0.0  0.3  42608  3176 ?        Ss   03:18   0:00 php-fpm: master process (/usr/local/php/etc/php-fpm.conf)                                                                    \r\n    www       62823  0.0  0.2  42608  2812 ?        S    03:18   0:00 php-fpm: pool www   \r\n\r\n可见启动成功，并且只有一个子进程，也就是pid为62823的进程。\r\nphp整个环境搭建完毕。\r\n下面就是安装nginx，配置nginx指向php-fpm。然后就可以调试了。\r\n编译安装nginx：\r\n首先要先安装pcre、zlib、openssl。\r\n然后下载源码：\r\n\r\n    wget \"http://nginx.org/download/nginx-1.7.10.tar.gz\"\r\n    tar -zxvf nginx-1.7.10.tar.gz\r\n    cd nginx-1.7.10.tar.gz\r\n    ./configure\r\n    make\r\n    make install\r\n\r\n这里./configure没有添加选项，如果要添加可以参考[官方配置][2]\r\n\r\nnginx server配置示例：\r\n\r\n    server\r\n    	{\r\n    		listen 80;\r\n    		#listen [::]:80;\r\n    		server_name test.com;\r\n    		index index.html index.htm index.php default.html default.htm default.php;\r\n    		root  /home/wwwroot/test.com;\r\n    \r\n    		include none.conf;\r\n    		#error_page   404   /404.html;\r\n    		location ~ [^/]\\.php(/|$)\r\n    			{\r\n    				# comment try_files $uri =404; to enable pathinfo\r\n    				#try_files $uri =404;\r\n    				fastcgi_pass  unix:/tmp/php-cgi.sock;\r\n    				fastcgi_index index.php;\r\n    				include fastcgi.conf;\r\n    				#include pathinfo.conf;\r\n    			}\r\n    \r\n    		location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\r\n    			{\r\n    				expires      30d;\r\n    			}\r\n    \r\n    		location ~ .*\\.(js|css)?$\r\n    			{\r\n    				expires      12h;\r\n    			}\r\n    \r\n    		#access_log  /home/wwwlogs/test.com.log  access;\r\n    	}\r\n\r\n\r\n\r\n  [1]: http://blog.dufei.cc/index.php/archives/10/\r\n  [2]: http://nginx.org/en/docs/configure.html',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(8,'nodejs简介','8',1425191640,1426230913,'<!--markdown-->研究分析是从设计者的意图出发，从抽象的甚至从哲学的高度，从最简单的系统原型开始，从设计猜想开始，而不是一开始就从代码分析展开。\r\nnodejs=8000行c++ + 2000行javascript。\r\n\r\n你是谁？从哪里来？到哪里去？这是保安和哲学家需要问的问题。对于一个新技术，我仍然可以按照这个框架来学习，来了解设计者的初心。\r\n我们就作一回保安，下面要来的是javascript。\r\n保安：你是谁？\r\njs：我可是个大名人，这是关于我的介绍：[wiki][1]。简单的说我是一个运行于浏览器的脚本语言，不需要编译，直接可运行。所谓的ajax技术就是我通过浏览器跟服务端打交道。动态操作页面dom结构也是我的拿手好戏。\r\n保安：你从哪里来？\r\njs: 我是网景公司程序员，前任mozilla CEO布兰登.艾克发明。虽然他因反对同性恋婚姻，上任10天就下台了，但是这都不能影响我的受欢迎程度。\r\n\r\n  [1]: http://zh.wikipedia.org/wiki/JavaScript',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(10,'php-fpm配置','10',1425269160,1425981317,'<!--markdown-->php-fpm配置文件在：**/usr/local/php/etc/php-fpm.conf**。里面包含了对fastcgi的各种配置信息，fastcgi启动的时候会读取改配置进行初始化和服务。php-fpm的配置包括**全局配置**和**局部配置**。全局配置很好理解，要想理解局部配置首先应该理解fastcgi的**pool**的概念。其实不难理解，pool你可以想成中国移动提供的不同的**套餐**，每个套餐有不同的收费项目和服务强度。一个fastcgi可以有多个套餐（pool），每个套餐（pool）的名字、服务端口、具体服务强度（派多少个子进程服务）等可能都不相同。\r\n\r\n首先如何查看当前系统配置信息状态？\r\n1、查看当前fastcgi状态：http://localhost/status\r\n\r\n\r\n    pool:                 www\r\n    process manager:      dynamic\r\n    start time:           02/Mar/2015:11:19:29 +0800\r\n    start since:          1764\r\n    accepted conn:        515097\r\n    listen queue:         0\r\n    max listen queue:     2\r\n    listen queue len:     128\r\n    idle processes:       115\r\n    active processes:     13\r\n    total processes:      128\r\n    max active processes: 34\r\n    max children reached: 0\r\n当然查看更详细的信息，展现方式也可以改变：\r\n\r\n    http://www.foo.bar/status?full\r\n    http://www.foo.bar/status?json&full\r\n    http://www.foo.bar/status?html&full\r\n    http://www.foo.bar/status?xml&full\r\n\r\n2、全局配置：\r\n\r\n    pid = /usr/local/php/var/run/php-fpm.pid\r\n    error_log = /usr/local/php/var/log/php-fpm.log\r\n    log_level = notice\r\n    ; If this number of child processes exit with SIGSEGV or SIGBUS within the time\r\n    ; interval set by emergency_restart_interval then FPM will restart. A value\r\n    ; of \'0\' means \'Off\'.\r\n    ; Default Value: 0\r\n    ;emergency_restart_threshold = 0\r\n    \r\n    ; Interval of time used by emergency_restart_interval to determine when\r\n    ; a graceful restart will be initiated.  This can be useful to work around\r\n    ; accidental corruptions in an accelerator\'s shared memory.\r\n    ; Available Units: s(econds), m(inutes), h(ours), or d(ays)\r\n    ; Default Unit: seconds\r\n    ; Default Value: 0\r\n    emergency_restart_interval = 24h\r\n    ; The maximum number of processes FPM will fork. This has been design to control\r\n    ; the global number of processes when using dynamic PM within a lot of pools.\r\n    ; Use it with caution.\r\n    ; Note: A value of 0 indicates no limit\r\n    ; Default Value: 0\r\n    ; process.max = 128\r\n    ; Specify the event mechanism FPM will use. The following is available:\r\n    ; - select     (any POSIX os)\r\n    ; - poll       (any POSIX os)\r\n    ; - epoll      (linux >= 2.5.44)\r\n    ; - kqueue     (FreeBSD >= 4.1, OpenBSD >= 2.9, NetBSD >= 2.0)\r\n    ; - /dev/poll  (Solaris >= 7)\r\n    ; - port       (Solaris >= 10)\r\n    ; Default Value: not set (auto detection)\r\n    ; events.mechanism = epoll\r\n    ; Set open file descriptor rlimit for the master process.\r\n    ; Default Value: system defined value\r\n    ;rlimit_files = 1024\r\n\r\n对于epoll的介绍，可以参考[通俗说EPOLL][1]。\r\n对于rlimit_files的配置这里多说下，这个参数是master进程打开文件描述符最大值得设定，默认是系统定义的大小。查看系统定义文件描述符限制命令为：\r\n\r\n    ulimit -n\r\n这个参数的设定必须和系统保持一致，也就是说即使这个参数设置成10240，但是系统只支持512，改参数也不会生效。如果想永久变更需要修改/etc/security/limits.conf 文件，如下：\r\n\r\n    vi /etc/security/limits.conf\r\n    * hard nofile 102400\r\n    * soft nofile 102400\r\n\r\n\r\n3、局部配置：\r\na、listen配置。可以看到这里可以选择服务ip（ip：port），也可以不选择（port）。\r\n\r\n    ; The address on which to accept FastCGI requests.\r\n    ; Valid syntaxes are:\r\n    ;   \'ip.add.re.ss:port\'    - to listen on a TCP socket to a specific address on\r\n    ;                            a specific port;\r\n    ;   \'port\'                 - to listen on a TCP socket to all addresses on a\r\n    ;                            specific port;\r\n    ;   \'/path/to/unix/socket\' - to listen on a unix socket.\r\n    ; Note: This value is mandatory.\r\n    listen = 127.0.0.1:9000\r\n\r\nb、子进程数量设置(process manager)：\r\n\r\n - 选择管理模式：static(静态)、dynamic（动态）、ondemand（需要时创建）\r\n\r\n\r\n    ; Choose how the process manager will control the number of child processes.\r\n    ; Possible Values:\r\n    ;   static  - a fixed number (pm.max_children) of child processes;\r\n    ;   dynamic - the number of child processes are set dynamically based on the\r\n    ;             following directives. With this process management, there will be\r\n    ;             always at least 1 children.\r\n    ;             pm.max_children      - the maximum number of children that can\r\n    ;                                    be alive at the same time.\r\n    ;             pm.start_servers     - the number of children created on startup.\r\n    ;             pm.min_spare_servers - the minimum number of children in \'idle\'\r\n    ;                                    state (waiting to process). If the number\r\n    ;                                    of \'idle\' processes is less than this\r\n    ;                                    number then some children will be created.\r\n    ;             pm.max_spare_servers - the maximum number of children in \'idle\'\r\n    ;                                    state (waiting to process). If the number\r\n    ;                                    of \'idle\' processes is greater than this\r\n    ;                                    number then some children will be killed.\r\n    ;  ondemand - no children are created at startup. Children will be forked when\r\n    ;             new requests will connect. The following parameter are used:\r\n    ;             pm.max_children           - the maximum number of children that\r\n    ;                                         can be alive at the same time.\r\n    ;             pm.process_idle_timeout   - The number of seconds after which\r\n    ;                                         an idle process will be killed.\r\n    ; Note: This value is mandatory.\r\n    pm = dynamic\r\n\r\n - 具体数量配置：pm.max_children（最大子进程数量）、pm.max_spare_servers（最大空闲子进程数量）、pm.min_spare_servers（最小空闲子进程数量）、pm.start_servers（初始子进程数量）\r\n\r\n\r\n    ; The number of child processes to be created when pm is set to \'static\' and the\r\n    ; maximum number of child processes when pm is set to \'dynamic\' or \'ondemand\'.\r\n    ; This value sets the limit on the number of simultaneous requests that will be\r\n    ; served. Equivalent to the ApacheMaxClients directive with mpm_prefork.\r\n    ; Equivalent to the PHP_FCGI_CHILDREN environment variable in the original PHP\r\n    ; CGI. The below defaults are based on a server without much resources. Don\'t\r\n    ; forget to tweak pm.* to fit your needs.\r\n    ; Note: Used when pm is set to \'static\', \'dynamic\' or \'ondemand\'\r\n    ; Note: This value is mandatory.\r\n    pm.max_children = 512\r\n\r\n    ; The number of child processes created on startup.\r\n    ; Note: Used only when pm is set to \'dynamic\'\r\n    ; Default Value: min_spare_servers + (max_spare_servers - min_spare_servers) / 2\r\n    pm.start_servers = 128\r\n    \r\n    ; The desired minimum number of idle server processes.\r\n    ; Note: Used only when pm is set to \'dynamic\'\r\n    ; Note: Mandatory when pm is set to \'dynamic\'\r\n    pm.min_spare_servers = 64\r\n    \r\n    ; The desired maximum number of idle server processes.\r\n    ; Note: Used only when pm is set to \'dynamic\'\r\n    ; Note: Mandatory when pm is set to \'dynamic\'\r\n    pm.max_spare_servers = 128\r\n    \r\n    \r\n\r\n - 子进程配置：m.process_idle_timeout（空闲子进程空闲多久关闭）、pm.max_requests（每个子进程最大服务次数）\r\n\r\n\r\n    ; The number of seconds after which an idle process will be killed.\r\n    ; Note: Used only when pm is set to \'ondemand\'\r\n    ; Default Value: 10s\r\n    ;pm.process_idle_timeout = 10s;\r\n    \r\n    ; The number of requests each child process should execute before respawning.\r\n    ; This can be useful to work around memory leaks in 3rd party libraries. For\r\n    ; endless request processing specify \'0\'. Equivalent to PHP_FCGI_MAX_REQUESTS.\r\n    ; Default Value: 0\r\n    pm.max_requests = 10000\r\n\r\n4、所有配置详情：\r\n\r\n    ;;;;;;;;;;;;;;;;;;;;;\r\n    ; FPM Configuration ;\r\n    ;;;;;;;;;;;;;;;;;;;;;\r\n    \r\n    ; All relative paths in this configuration file are relative to PHP\'s install\r\n    ; prefix (/usr/local/php). This prefix can be dynamicaly changed by using the\r\n    ; \'-p\' argument from the command line.\r\n    \r\n    ; Include one or more files. If glob(3) exists, it is used to include a bunch of\r\n    ; files from a glob(3) pattern. This directive can be used everywhere in the\r\n    ; file.\r\n    ; Relative path can also be used. They will be prefixed by:\r\n    ;  - the global prefix if it\'s been set (-p arguement)\r\n    ;  - /usr/local/php otherwise\r\n    ;include=etc/fpm.d/*.conf\r\n    \r\n    ;;;;;;;;;;;;;;;;;;\r\n    ; Global Options ;\r\n    ;;;;;;;;;;;;;;;;;;\r\n    \r\n    [global]\r\n    ; Pid file\r\n    ; Note: the default prefix is /data/php\r\n    ; Default Value: none\r\n    pid = /var/run/php-fpm.pid\r\n    \r\n    ; Error log file\r\n    ; If it\'s set to \"syslog\", log is sent to syslogd instead of being written\r\n    ; in a local file.\r\n    ; Note: the default prefix is /data/php\r\n    ; Default Value: log/php-fpm.log\r\n    error_log = /data/php/log/php-fpm.log\r\n    \r\n    ; syslog_facility is used to specify what type of program is logging the\r\n    ; message. This lets syslogd specify that messages from different facilities\r\n    ; will be handled differently.\r\n    ; See syslog(3) for possible values (ex daemon equiv LOG_DAEMON)\r\n    ; Default Value: daemon\r\n    ;syslog.facility = daemon\r\n    \r\n    ; syslog_ident is prepended to every message. If you have multiple FPM\r\n    ; instances running on the same server, you can change the default value\r\n    ; which must suit common needs.\r\n    ; Default Value: php-fpm\r\n    ;syslog.ident = php-fpm\r\n    \r\n    ; Log level\r\n    ; Possible Values: alert, error, warning, notice, debug\r\n    ; Default Value: notice\r\n    log_level = warning\r\n    \r\n    ; If this number of child processes exit with SIGSEGV or SIGBUS within the time\r\n    ; interval set by emergency_restart_interval then FPM will restart. A value\r\n    ; of \'0\' means \'Off\'.\r\n    ; Default Value: 0\r\n    ;emergency_restart_threshold = 0\r\n    \r\n    ; Interval of time used by emergency_restart_interval to determine when \r\n    ; a graceful restart will be initiated.  This can be useful to work around\r\n    ; accidental corruptions in an accelerator\'s shared memory.\r\n    ; Available Units: s(econds), m(inutes), h(ours), or d(ays)\r\n    ; Default Unit: seconds\r\n    ; Default Value: 0\r\n    emergency_restart_interval = 24h\r\n    \r\n    ; Time limit for child processes to wait for a reaction on signals from master.\r\n    ; Available units: s(econds), m(inutes), h(ours), or d(ays)\r\n    ; Default Unit: seconds\r\n    ; Default Value: 0\r\n    process_control_timeout = 5s\r\n    \r\n    ; The maximum number of processes FPM will fork. This has been design to control\r\n    ; the global number of processes when using dynamic PM within a lot of pools.\r\n    ; Use it with caution.\r\n    ; Note: A value of 0 indicates no limit\r\n    ; Default Value: 0\r\n    ; process.max = 128\r\n    \r\n    ; Specify the nice(2) priority to apply to the master process (only if set)\r\n    ; The value can vary from -19 (highest priority) to 20 (lower priority)\r\n    ; Note: - It will only work if the FPM master process is launched as root\r\n    ;       - The pool process will inherit the master process priority\r\n    ;         unless it specified otherwise\r\n    ; Default Value: no set\r\n    ; process.priority = -19\r\n    \r\n    ; Send FPM to background. Set to \'no\' to keep FPM in foreground for debugging.\r\n    ; Default Value: yes\r\n    daemonize = yes\r\n     \r\n    ; Set open file descriptor rlimit for the master process.\r\n    ; Default Value: system defined value\r\n    rlimit_files = 10240\r\n     \r\n    ; Set max core size rlimit for the master process.\r\n    ; Possible Values: \'unlimited\' or an integer greater or equal to 0\r\n    ; Default Value: system defined value\r\n    rlimit_core = unlimited\r\n    \r\n    ; Specify the event mechanism FPM will use. The following is available:\r\n    ; - select     (any POSIX os)\r\n    ; - poll       (any POSIX os)\r\n    ; - epoll      (linux >= 2.5.44)\r\n    ; - kqueue     (FreeBSD >= 4.1, OpenBSD >= 2.9, NetBSD >= 2.0)\r\n    ; - /dev/poll  (Solaris >= 7)\r\n    ; - port       (Solaris >= 10)\r\n    ; Default Value: not set (auto detection)\r\n    ; events.mechanism = epoll\r\n    \r\n    ;;;;;;;;;;;;;;;;;;;;\r\n    ; Pool Definitions ; \r\n    ;;;;;;;;;;;;;;;;;;;;\r\n    \r\n    ; Multiple pools of child processes may be started with different listening\r\n    ; ports and different management options.  The name of the pool will be\r\n    ; used in logs and stats. There is no limitation on the number of pools which\r\n    ; FPM can handle. Your system will tell you anyway :)\r\n    \r\n    ; Start a new pool named \'www\'.\r\n    ; the variable $pool can we used in any directive and will be replaced by the\r\n    ; pool name (\'www\' here)\r\n    [www]\r\n    \r\n    ; Per pool prefix\r\n    ; It only applies on the following directives:\r\n    ; - \'slowlog\'\r\n    ; - \'listen\' (unixsocket)\r\n    ; - \'chroot\'\r\n    ; - \'chdir\'\r\n    ; - \'php_values\'\r\n    ; - \'php_admin_values\'\r\n    ; When not set, the global prefix (or /usr/local/php) applies instead.\r\n    ; Note: This directive can also be relative to the global prefix.\r\n    ; Default Value: none\r\n    ;prefix = /path/to/pools/$pool\r\n    \r\n    ; Unix user/group of processes\r\n    ; Note: The user is mandatory. If the group is not set, the default user\'s group\r\n    ;       will be used.\r\n    user = nobody\r\n    group = nobody\r\n    \r\n    ; The address on which to accept FastCGI requests.\r\n    ; Valid syntaxes are:\r\n    ;   \'ip.add.re.ss:port\'    - to listen on a TCP socket to a specific address on\r\n    ;                            a specific port;\r\n    ;   \'port\'                 - to listen on a TCP socket to all addresses on a\r\n    ;                            specific port;\r\n    ;   \'/path/to/unix/socket\' - to listen on a unix socket.\r\n    ; Note: This value is mandatory.\r\n    listen = 127.0.0.1:9000\r\n    \r\n    ; Set listen(2) backlog. A value of \'-1\' means unlimited.\r\n    ; Default Value: 128 (-1 on FreeBSD and OpenBSD)\r\n    ;listen.backlog = -1\r\n    \r\n    ; Set permissions for unix socket, if one is used. In Linux, read/write\r\n    ; permissions must be set in order to allow connections from a web server. Many\r\n    ; BSD-derived systems allow connections regardless of permissions. \r\n    ; Default Values: user and group are set as the running user\r\n    ;                 mode is set to 0666\r\n    listen.owner = nobody\r\n    listen.group = nobody\r\n    listen.mode = 0666\r\n     \r\n    ; List of ipv4 addresses of FastCGI clients which are allowed to connect.\r\n    ; Equivalent to the FCGI_WEB_SERVER_ADDRS environment variable in the original\r\n    ; PHP FCGI (5.2.2+). Makes sense only with a tcp listening socket. Each address\r\n    ; must be separated by a comma. If this value is left blank, connections will be\r\n    ; accepted from any ip address.\r\n    ; Default Value: any\r\n    listen.allowed_clients = 127.0.0.1\r\n    \r\n    ; Specify the nice(2) priority to apply to the pool processes (only if set)\r\n    ; The value can vary from -19 (highest priority) to 20 (lower priority)\r\n    ; Note: - It will only work if the FPM master process is launched as root\r\n    ;       - The pool processes will inherit the master process priority\r\n    ;         unless it specified otherwise\r\n    ; Default Value: no set\r\n    ; priority = -19\r\n    \r\n    ; Choose how the process manager will control the number of child processes.\r\n    ; Possible Values:\r\n    ;   static  - a fixed number (pm.max_children) of child processes;\r\n    ;   dynamic - the number of child processes are set dynamically based on the\r\n    ;             following directives. With this process management, there will be\r\n    ;             always at least 1 children.\r\n    ;             pm.max_children      - the maximum number of children that can\r\n    ;                                    be alive at the same time.\r\n    ;             pm.start_servers     - the number of children created on startup.\r\n    ;             pm.min_spare_servers - the minimum number of children in \'idle\'\r\n    ;                                    state (waiting to process). If the number\r\n    ;                                    of \'idle\' processes is less than this\r\n    ;                                    number then some children will be created.\r\n    ;             pm.max_spare_servers - the maximum number of children in \'idle\'\r\n    ;                                    state (waiting to process). If the number\r\n    ;                                    of \'idle\' processes is greater than this\r\n    ;                                    number then some children will be killed.\r\n    ;  ondemand - no children are created at startup. Children will be forked when\r\n    ;             new requests will connect. The following parameter are used:\r\n    ;             pm.max_children           - the maximum number of children that\r\n    ;                                         can be alive at the same time.\r\n    ;             pm.process_idle_timeout   - The number of seconds after which\r\n    ;                                         an idle process will be killed.\r\n    ; Note: This value is mandatory.\r\n    pm = dynamic\r\n    \r\n    ; The number of child processes to be created when pm is set to \'static\' and the\r\n    ; maximum number of child processes when pm is set to \'dynamic\' or \'ondemand\'.\r\n    ; This value sets the limit on the number of simultaneous requests that will be\r\n    ; served. Equivalent to the ApacheMaxClients directive with mpm_prefork.\r\n    ; Equivalent to the PHP_FCGI_CHILDREN environment variable in the original PHP\r\n    ; CGI. The below defaults are based on a server without much resources. Don\'t\r\n    ; forget to tweak pm.* to fit your needs.\r\n    ; Note: Used when pm is set to \'static\', \'dynamic\' or \'ondemand\'\r\n    ; Note: This value is mandatory.\r\n    pm.max_children = 512\r\n    \r\n    ; The number of child processes created on startup.\r\n    ; Note: Used only when pm is set to \'dynamic\'\r\n    ; Default Value: min_spare_servers + (max_spare_servers - min_spare_servers) / 2\r\n    pm.start_servers = 128\r\n    \r\n    ; The desired minimum number of idle server processes.\r\n    ; Note: Used only when pm is set to \'dynamic\'\r\n    ; Note: Mandatory when pm is set to \'dynamic\'\r\n    pm.min_spare_servers = 64\r\n    \r\n    ; The desired maximum number of idle server processes.\r\n    ; Note: Used only when pm is set to \'dynamic\'\r\n    ; Note: Mandatory when pm is set to \'dynamic\'\r\n    pm.max_spare_servers = 128\r\n    \r\n    ; The number of seconds after which an idle process will be killed.\r\n    ; Note: Used only when pm is set to \'ondemand\'\r\n    ; Default Value: 10s\r\n    ;pm.process_idle_timeout = 10s;\r\n     \r\n    ; The number of requests each child process should execute before respawning.\r\n    ; This can be useful to work around memory leaks in 3rd party libraries. For\r\n    ; endless request processing specify \'0\'. Equivalent to PHP_FCGI_MAX_REQUESTS.\r\n    ; Default Value: 0\r\n    pm.max_requests = 10000\r\n    \r\n    ; The URI to view the FPM status page. If this value is not set, no URI will be\r\n    ; recognized as a status page. It shows the following informations:\r\n    ;   pool                 - the name of the pool;\r\n    ;   process manager      - static, dynamic or ondemand;\r\n    ;   start time           - the date and time FPM has started;\r\n    ;   start since          - number of seconds since FPM has started;\r\n    ;   accepted conn        - the number of request accepted by the pool;\r\n    ;   listen queue         - the number of request in the queue of pending\r\n    ;                          connections (see backlog in listen(2));\r\n    ;   max listen queue     - the maximum number of requests in the queue\r\n    ;                          of pending connections since FPM has started;\r\n    ;   listen queue len     - the size of the socket queue of pending connections;\r\n    ;   idle processes       - the number of idle processes;\r\n    ;   active processes     - the number of active processes;\r\n    ;   total processes      - the number of idle + active processes;\r\n    ;   max active processes - the maximum number of active processes since FPM\r\n    ;                          has started;\r\n    ;   max children reached - number of times, the process limit has been reached,\r\n    ;                          when pm tries to start more children (works only for\r\n    ;                          pm \'dynamic\' and \'ondemand\');\r\n    ; Value are updated in real time.\r\n    ; Example output:\r\n    ;   pool:                 www\r\n    ;   process manager:      static\r\n    ;   start time:           01/Jul/2011:17:53:49 +0200\r\n    ;   start since:          62636\r\n    ;   accepted conn:        190460\r\n    ;   listen queue:         0\r\n    ;   max listen queue:     1\r\n    ;   listen queue len:     42\r\n    ;   idle processes:       4\r\n    ;   active processes:     11\r\n    ;   total processes:      15\r\n    ;   max active processes: 12\r\n    ;   max children reached: 0\r\n    ;\r\n    ; By default the status page output is formatted as text/plain. Passing either\r\n    ; \'html\', \'xml\' or \'json\' in the query string will return the corresponding\r\n    ; output syntax. Example:\r\n    ;   http://www.foo.bar/status\r\n    ;   http://www.foo.bar/status?json\r\n    ;   http://www.foo.bar/status?html\r\n    ;   http://www.foo.bar/status?xml\r\n    ;\r\n    ; By default the status page only outputs short status. Passing \'full\' in the\r\n    ; query string will also return status for each pool process.\r\n    ; Example: \r\n    ;   http://www.foo.bar/status?full\r\n    ;   http://www.foo.bar/status?json&full\r\n    ;   http://www.foo.bar/status?html&full\r\n    ;   http://www.foo.bar/status?xml&full\r\n    ; The Full status returns for each process:\r\n    ;   pid                  - the PID of the process;\r\n    ;   state                - the state of the process (Idle, Running, ...);\r\n    ;   start time           - the date and time the process has started;\r\n    ;   start since          - the number of seconds since the process has started;\r\n    ;   requests             - the number of requests the process has served;\r\n    ;   request duration     - the duration in µs of the requests;\r\n    ;   request method       - the request method (GET, POST, ...);\r\n    ;   request URI          - the request URI with the query string;\r\n    ;   content length       - the content length of the request (only with POST);\r\n    ;   user                 - the user (PHP_AUTH_USER) (or \'-\' if not set);\r\n    ;   script               - the main script called (or \'-\' if not set);\r\n    ;   last request cpu     - the %cpu the last request consumed\r\n    ;                          it\'s always 0 if the process is not in Idle state\r\n    ;                          because CPU calculation is done when the request\r\n    ;                          processing has terminated;\r\n    ;   last request memory  - the max amount of memory the last request consumed\r\n    ;                          it\'s always 0 if the process is not in Idle state\r\n    ;                          because memory calculation is done when the request\r\n    ;                          processing has terminated;\r\n    ; If the process is in Idle state, then informations are related to the\r\n    ; last request the process has served. Otherwise informations are related to\r\n    ; the current request being served.\r\n    ; Example output:\r\n    ;   ************************\r\n    ;   pid:                  31330\r\n    ;   state:                Running\r\n    ;   start time:           01/Jul/2011:17:53:49 +0200\r\n    ;   start since:          63087\r\n    ;   requests:             12808\r\n    ;   request duration:     1250261\r\n    ;   request method:       GET\r\n    ;   request URI:          /test_mem.php?N=10000\r\n    ;   content length:       0\r\n    ;   user:                 -\r\n    ;   script:               /home/fat/web/docs/php/test_mem.php\r\n    ;   last request cpu:     0.00\r\n    ;   last request memory:  0\r\n    ;\r\n    ; Note: There is a real-time FPM status monitoring sample web page available\r\n    ;       It\'s available in: /usr/local/share/php/fpm/status.html\r\n    ;\r\n    ; Note: The value must start with a leading slash (/). The value can be\r\n    ;       anything, but it may not be a good idea to use the .php extension or it\r\n    ;       may conflict with a real PHP file.\r\n    ; Default Value: not set \r\n    pm.status_path = /status\r\n     \r\n    ; The ping URI to call the monitoring page of FPM. If this value is not set, no\r\n    ; URI will be recognized as a ping page. This could be used to test from outside\r\n    ; that FPM is alive and responding, or to\r\n    ; - create a graph of FPM availability (rrd or such);\r\n    ; - remove a server from a group if it is not responding (load balancing);\r\n    ; - trigger alerts for the operating team (24/7).\r\n    ; Note: The value must start with a leading slash (/). The value can be\r\n    ;       anything, but it may not be a good idea to use the .php extension or it\r\n    ;       may conflict with a real PHP file.\r\n    ; Default Value: not set\r\n    ;ping.path = /ping\r\n    \r\n    ; This directive may be used to customize the response of a ping request. The\r\n    ; response is formatted as text/plain with a 200 response code.\r\n    ; Default Value: pong\r\n    ;ping.response = pong\r\n    \r\n    ; The access log file\r\n    ; Default: not set\r\n    ;access.log = /data/php/log/$pool.access.log\r\n    \r\n    ; The access log format.\r\n    ; The following syntax is allowed\r\n    ;  %%: the \'%\' character\r\n    ;  %C: %CPU used by the request\r\n    ;      it can accept the following format:\r\n    ;      - %{user}C for user CPU only\r\n    ;      - %{system}C for system CPU only\r\n    ;      - %{total}C  for user + system CPU (default)\r\n    ;  %d: time taken to serve the request\r\n    ;      it can accept the following format:\r\n    ;      - %{seconds}d (default)\r\n    ;      - %{miliseconds}d\r\n    ;      - %{mili}d\r\n    ;      - %{microseconds}d\r\n    ;      - %{micro}d\r\n    ;  %e: an environment variable (same as $_ENV or $_SERVER)\r\n    ;      it must be associated with embraces to specify the name of the env\r\n    ;      variable. Some exemples:\r\n    ;      - server specifics like: %{REQUEST_METHOD}e or %{SERVER_PROTOCOL}e\r\n    ;      - HTTP headers like: %{HTTP_HOST}e or %{HTTP_USER_AGENT}e\r\n    ;  %f: script filename\r\n    ;  %l: content-length of the request (for POST request only)\r\n    ;  %m: request method\r\n    ;  %M: peak of memory allocated by PHP\r\n    ;      it can accept the following format:\r\n    ;      - %{bytes}M (default)\r\n    ;      - %{kilobytes}M\r\n    ;      - %{kilo}M\r\n    ;      - %{megabytes}M\r\n    ;      - %{mega}M\r\n    ;  %n: pool name\r\n    ;  %o: ouput header\r\n    ;      it must be associated with embraces to specify the name of the header:\r\n    ;      - %{Content-Type}o\r\n    ;      - %{X-Powered-By}o\r\n    ;      - %{Transfert-Encoding}o\r\n    ;      - ....\r\n    ;  %p: PID of the child that serviced the request\r\n    ;  %P: PID of the parent of the child that serviced the request\r\n    ;  %q: the query string \r\n    ;  %Q: the \'?\' character if query string exists\r\n    ;  %r: the request URI (without the query string, see %q and %Q)\r\n    ;  %R: remote IP address\r\n    ;  %s: status (response code)\r\n    ;  %t: server time the request was received\r\n    ;      it can accept a strftime(3) format:\r\n    ;      %d/%b/%Y:%H:%M:%S %z (default)\r\n    ;  %T: time the log has been written (the request has finished)\r\n    ;      it can accept a strftime(3) format:\r\n    ;      %d/%b/%Y:%H:%M:%S %z (default)\r\n    ;  %u: remote user\r\n    ;\r\n    ; Default: \"%R - %u %t \\\"%m %r\\\" %s\"\r\n    ;access.format = \"%R - %u %t \\\"%m %r%Q%q\\\" %s %f %{mili}d %{kilo}M %C%%\"\r\n     \r\n    ; The log file for slow requests\r\n    ; Default Value: not set\r\n    ; Note: slowlog is mandatory if request_slowlog_timeout is set\r\n    slowlog = /data/php/log/$pool.log.slow\r\n     \r\n    ; The timeout for serving a single request after which a PHP backtrace will be\r\n    ; dumped to the \'slowlog\' file. A value of \'0s\' means \'off\'.\r\n    ; Available units: s(econds)(default), m(inutes), h(ours), or d(ays)\r\n    ; Default Value: 0\r\n    request_slowlog_timeout = 10\r\n     \r\n    ; The timeout for serving a single request after which the worker process will\r\n    ; be killed. This option should be used when the \'max_execution_time\' ini option\r\n    ; does not stop script execution for some reason. A value of \'0\' means \'off\'.\r\n    ; Available units: s(econds)(default), m(inutes), h(ours), or d(ays)\r\n    ; Default Value: 0\r\n    ;request_terminate_timeout = 0\r\n     \r\n    ; Set open file descriptor rlimit.\r\n    ; Default Value: system defined value\r\n    rlimit_files = 10240\r\n     \r\n    ; Set max core size rlimit.\r\n    ; Possible Values: \'unlimited\' or an integer greater or equal to 0\r\n    ; Default Value: system defined value\r\n    rlimit_core = unlimited\r\n     \r\n    ; Chroot to this directory at the start. This value must be defined as an\r\n    ; absolute path. When this value is not set, chroot is not used.\r\n    ; Note: you can prefix with \'$prefix\' to chroot to the pool prefix or one\r\n    ; of its subdirectories. If the pool prefix is not set, the global prefix\r\n    ; will be used instead.\r\n    ; Note: chrooting is a great security feature and should be used whenever \r\n    ;       possible. However, all PHP paths will be relative to the chroot\r\n    ;       (error_log, sessions.save_path, ...).\r\n    ; Default Value: not set\r\n    ;chroot = \r\n     \r\n    ; Chdir to this directory at the start.\r\n    ; Note: relative path can be used.\r\n    ; Default Value: current directory or / when chroot\r\n    ;chdir = /var/www\r\n     \r\n    ; Redirect worker stdout and stderr into main error log. If not set, stdout and\r\n    ; stderr will be redirected to /dev/null according to FastCGI specs.\r\n    ; Note: on highloaded environement, this can cause some delay in the page\r\n    ; process time (several ms).\r\n    ; Default Value: no\r\n    ;catch_workers_output = yes\r\n    \r\n    ; Limits the extensions of the main script FPM will allow to parse. This can\r\n    ; prevent configuration mistakes on the web server side. You should only limit\r\n    ; FPM to .php extensions to prevent malicious users to use other extensions to\r\n    ; exectute php code.\r\n    ; Note: set an empty value to allow all extensions.\r\n    ; Default Value: .php\r\n    ;security.limit_extensions = .php .php3 .php4 .php5\r\n     \r\n    ; Pass environment variables like LD_LIBRARY_PATH. All $VARIABLEs are taken from\r\n    ; the current environment.\r\n    ; Default Value: clean env\r\n    env[HOSTNAME] = $HOSTNAME\r\n    env[PATH] = /usr/local/bin:/usr/bin:/bin\r\n    env[TMP] = /tmp\r\n    env[TMPDIR] = /tmp\r\n    env[TEMP] = /tmp\r\n    \r\n    ; Additional php.ini defines, specific to this pool of workers. These settings\r\n    ; overwrite the values previously defined in the php.ini. The directives are the\r\n    ; same as the PHP SAPI:\r\n    ;   php_value/php_flag             - you can set classic ini defines which can\r\n    ;                                    be overwritten from PHP call \'ini_set\'. \r\n    ;   php_admin_value/php_admin_flag - these directives won\'t be overwritten by\r\n    ;                                     PHP call \'ini_set\'\r\n    ; For php_*flag, valid values are on, off, 1, 0, true, false, yes or no.\r\n    \r\n    ; Defining \'extension\' will load the corresponding shared extension from\r\n    ; extension_dir. Defining \'disable_functions\' or \'disable_classes\' will not\r\n    ; overwrite previously defined php.ini values, but will append the new value\r\n    ; instead.\r\n    \r\n    ; Note: path INI options can be relative and will be expanded with the prefix\r\n    ; (pool, global or /usr/local/php)\r\n    \r\n    ; Default Value: nothing is defined by default except the values in php.ini and\r\n    ;                specified at startup with the -d argument\r\n    ;php_admin_value[sendmail_path] = /usr/sbin/sendmail -t -i -f www@my.domain.com\r\n    php_flag[display_errors] = off\r\n    php_flag[display_startup_errors] = off\r\n    ;php_admin_value[error_log] = /var/log/fpm-php.www.log\r\n    ;php_admin_flag[log_errors] = on\r\n\r\n    \r\n\r\n\r\n  [1]: http://blog.dufei.cc/index.php/archives/15/',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(22,'epoll在php-fpm中的应用','22',1426163640,1426491330,'<!--markdown-->epoll的操作主要有3个函数：\r\n1、函数声明：int epoll_create(int size)\r\n2、将被监听的描述符添加到epoll句柄或从epool句柄中删除或者对监听事件进行修改。\r\n函数声明：int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)\r\n该函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，删除事件。\r\n参数：\r\nepfd：由 epoll_create 生成的epoll专用的文件描述符；\r\nop：要进行的操作例如注册事件，可能的取值EPOLL_CTL_ADD 注册、EPOLL_CTL_MOD 修 改、EPOLL_CTL_DEL 删除\r\nfd：关联的文件描述符；\r\nevent：指向epoll_event的指针；\r\n如果调用成功返回0,不成功返回-1\r\n\r\n    typedef union epoll_data {  \r\n    void *ptr;  \r\n    int fd;  \r\n    __uint32_t u32;  \r\n    __uint64_t u64;  \r\n    } epoll_data_t;  \r\n      \r\n    struct epoll_event {  \r\n    __uint32_t events; /* Epoll events */  \r\n    epoll_data_t data; /* User data variable */  \r\n    }; \r\n\r\n\r\nevents可以是以下几个宏的集合：\r\nEPOLLIN：     触发该事件，表示对应的文件描述符上有可读数据。(包括对端SOCKET正常关闭)；\r\nEPOLLOUT：    触发该事件，表示对应的文件描述符上可以写数据；\r\nEPOLLPRI：    表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；\r\nEPOLLERR：    表示对应的文件描述符发生错误；\r\nEPOLLHUP：    表示对应的文件描述符被挂断；\r\nEPOLLET：     将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。\r\nEPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。\r\n \r\n3、 int epoll_wait(int epfd, struct epoll_event * events, intmaxevents, int timeout);\r\n等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大(数组成员的个数)，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。返回的事件集合在events数组中，数组中实际存放的成员个数是函数的返回值。返回0表示已经超时。\r\n\r\nphp-fpm对epoll的3个函数做了一次封装。代码如下：\r\n   \r\n    \r\n    #include \"../fpm_config.h\"\r\n    #include \"../fpm_events.h\"\r\n    #include \"../fpm.h\"\r\n    #include \"../zlog.h\"\r\n    \r\n    #if HAVE_EPOLL\r\n    \r\n    #include <sys/epoll.h>\r\n    #include <errno.h>\r\n    \r\n    static int fpm_event_epoll_init(int max);\r\n    static int fpm_event_epoll_clean();\r\n    static int fpm_event_epoll_wait(struct fpm_event_queue_s *queue, unsigned long int timeout);\r\n    static int fpm_event_epoll_add(struct fpm_event_s *ev);\r\n    static int fpm_event_epoll_remove(struct fpm_event_s *ev);\r\n    \r\n    static struct fpm_event_module_s epoll_module = {\r\n    	.name = \"epoll\",\r\n    	.support_edge_trigger = 1,\r\n    	.init = fpm_event_epoll_init,\r\n    	.clean = fpm_event_epoll_clean,\r\n    	.wait = fpm_event_epoll_wait,\r\n    	.add = fpm_event_epoll_add,\r\n    	.remove = fpm_event_epoll_remove, \r\n    };\r\n    \r\n    static struct epoll_event *epollfds = NULL;\r\n    static int nepollfds = 0;\r\n    static int epollfd = -1;\r\n    \r\n    #endif /* HAVE_EPOLL */\r\n    \r\n    struct fpm_event_module_s *fpm_event_epoll_module() /* {{{ */\r\n    {\r\n    #if HAVE_EPOLL\r\n    	return &epoll_module;\r\n    #else\r\n    	return NULL;\r\n    #endif /* HAVE_EPOLL */\r\n    }\r\n    /* }}} */\r\n    \r\n    #if HAVE_EPOLL\r\n    \r\n    /*\r\n     * Init the module\r\n     */\r\n    static int fpm_event_epoll_init(int max) /* {{{ */\r\n    {\r\n    	if (max < 1) {\r\n    		return 0;\r\n    	}\r\n    \r\n    	/* init epoll */\r\n    	epollfd = epoll_create(max + 1);\r\n    	if (epollfd < 0) {\r\n    		zlog(ZLOG_ERROR, \"epoll: unable to initialize\");\r\n    		return -1;\r\n    	}\r\n    \r\n    	/* allocate fds */\r\n    	epollfds = malloc(sizeof(struct epoll_event) * max);\r\n    	if (!epollfds) {\r\n    		zlog(ZLOG_ERROR, \"epoll: unable to allocate %d events\", max);\r\n    		return -1;\r\n    	}\r\n    	memset(epollfds, 0, sizeof(struct epoll_event) * max);\r\n    \r\n    	/* save max */\r\n    	nepollfds = max;\r\n    \r\n    	return 0;\r\n    }\r\n    /* }}} */\r\n    \r\n    /*\r\n     * Clean the module\r\n     */\r\n    static int fpm_event_epoll_clean() /* {{{ */\r\n    {\r\n    	/* free epollfds */\r\n    	if (epollfds) {\r\n    		free(epollfds);\r\n    		epollfds = NULL;\r\n    	}\r\n    	if (epollfd != -1) {\r\n    		close(epollfd);\r\n    		epollfd = -1;\r\n    	}\r\n    \r\n    	nepollfds = 0;\r\n    \r\n    	return 0;\r\n    }\r\n    /* }}} */\r\n    \r\n    /*\r\n     * wait for events or timeout\r\n     */\r\n    static int fpm_event_epoll_wait(struct fpm_event_queue_s *queue, unsigned long int timeout) /* {{{ */\r\n    {\r\n    	int ret, i;\r\n    \r\n    	/* ensure we have a clean epoolfds before calling epoll_wait() */\r\n    	memset(epollfds, 0, sizeof(struct epoll_event) * nepollfds);\r\n    \r\n    	/* wait for inconming event or timeout */\r\n    	ret = epoll_wait(epollfd, epollfds, nepollfds, timeout);\r\n    	if (ret == -1) {\r\n    \r\n    		/* trigger error unless signal interrupt */\r\n    		if (errno != EINTR) {\r\n    			zlog(ZLOG_WARNING, \"epoll_wait() returns %d\", errno);\r\n    			return -1;\r\n    		}\r\n    	}\r\n    \r\n    	/* events have been triggered, let\'s fire them */\r\n    	for (i = 0; i < ret; i++) {\r\n    \r\n    		/* do we have a valid ev ptr ? */\r\n    		if (!epollfds[i].data.ptr) {\r\n    			continue;\r\n    		}\r\n    \r\n    		/* fire the event */\r\n    		fpm_event_fire((struct fpm_event_s *)epollfds[i].data.ptr);\r\n    \r\n    		/* sanity check */\r\n    		if (fpm_globals.parent_pid != getpid()) {\r\n    			return -2;\r\n    		}\r\n    	}\r\n    \r\n    	return ret;\r\n    }\r\n    /* }}} */\r\n    \r\n    /*\r\n     * Add a FD to the fd set\r\n     */\r\n    static int fpm_event_epoll_add(struct fpm_event_s *ev) /* {{{ */\r\n    {\r\n    	struct epoll_event e;\r\n    \r\n    	/* fill epoll struct */\r\n    	e.events = EPOLLIN;\r\n    	e.data.fd = ev->fd;\r\n    	e.data.ptr = (void *)ev;\r\n    \r\n    	if (ev->flags & FPM_EV_EDGE) {\r\n    		e.events = e.events | EPOLLET;\r\n    	}\r\n    \r\n    	/* add the event to epoll internal queue */\r\n    	if (epoll_ctl(epollfd, EPOLL_CTL_ADD, ev->fd, &e) == -1) {\r\n    		zlog(ZLOG_ERROR, \"epoll: unable to add fd %d\", ev->fd);\r\n    		return -1;\r\n    	}\r\n    \r\n    	/* mark the event as registered */\r\n    	ev->index = ev->fd;\r\n    	return 0;\r\n    }\r\n    /* }}} */\r\n    \r\n    /*\r\n     * Remove a FD from the fd set\r\n     */\r\n    static int fpm_event_epoll_remove(struct fpm_event_s *ev) /* {{{ */\r\n    {\r\n    	struct epoll_event e;\r\n    \r\n    	/* fill epoll struct the same way we did in fpm_event_epoll_add() */\r\n    	e.events = EPOLLIN;\r\n    	e.data.fd = ev->fd;\r\n    	e.data.ptr = (void *)ev;\r\n    \r\n    	if (ev->flags & FPM_EV_EDGE) {\r\n    		e.events = e.events | EPOLLET;\r\n    	}\r\n    \r\n    	/* remove the event from epoll internal queue */\r\n    	if (epoll_ctl(epollfd, EPOLL_CTL_DEL, ev->fd, &e) == -1) {\r\n    		zlog(ZLOG_ERROR, \"epoll: unable to remove fd %d\", ev->fd);\r\n    		return -1;\r\n    	}\r\n    \r\n    	/* mark the event as not registered */\r\n    	ev->index = -1;\r\n    	return 0;\r\n    }\r\n    /* }}} */\r\n    \r\n    #endif /* HAVE_EPOLL */',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(37,'大数据处理思路','37',1429346400,1443439633,'<!--markdown-->提到大数据会想到什么？分布式？hadoop、strom、spark等成熟的开源解决方案？这里我们都不讨论，这里简单的讨论下大数据处理思想和简单的方法和思想与原则。\r\n\r\n何谓大数据？大数据应该数据量非常大，不能放到内存处理，甚至可能不能放到单台机器上处理。\r\n处理大数据的核心思想是分而治之。分而治之其实就是一个分、合的问题。大数据首先要根据一定得规则切分成小数据，这个切分方式要保证同类数据在同一个小数据集合里面。每个小数据集合通过处理后接下来就是要把每个小数据集合的计算结果合并起来。下面开始探讨分合。\r\n\r\n分\r\n-\r\n分的原则：\r\n1、这里的分不是随意乱分，分要使一类的数据尽量分配在一起，这样做的好处是最后每个分片最后的处理结果比较少，最后合的时候也比较方便。\r\n2、分可以不只一次，可以进行多次分割。比如求中位数，或者要在很多数据中找其中一部分内容，可以进行多次分割，逐步逼近的方法。\r\n\r\n分的方法：\r\n1、普通hash%分割的文件数\r\n2、一致性哈希，具体见本blog的[一致性hash及memcache的实现方式][1]\r\n\r\n分片处理\r\n----\r\n对于分片的处理，有几种常用的数据结构和技术需要知道。\r\n1、bitmap\r\n2、hashtable\r\n3、堆排序\r\n4、归并排序\r\n5、bloom filter\r\n6、trie 树\r\n7、倒排索引\r\n8、快速排序\r\n9、map、reduce\r\n\r\n\r\n合\r\n-\r\n将各个部分的处理结果合并起来。\r\n\r\n有点时候可能要经历多次分合，最后达到要求。\r\n\r\n\r\n  [1]: http://blog.dufei.cc',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(38,'文明与自己','38',1431755640,1433064764,'<!--markdown-->如果说我们我们人类经过几千万年的进化，站在了食物链的最顶端，那么作为食物链最顶端的我们为什么最后还是无法避免的会化为尘土呢。几千年的进化，我们真的达到了食物链最顶端的荣耀了吗？\r\n\r\n如果说动物吞噬植物，人类（让我们姑且凌驾于动物之上）吞噬动物。植物这个个体输入阳光雨露，输出有机养料、种子，最后被吃掉或者死亡。动物也是一样。动物和植物都是被动生存，即使通过自然选择，他们进化的更加适应环境，终究还是一个被动接受命运安排的过程。\r\n再说我们人类，相比于没有智商，或者智商偏低的动植物，我们有了自己的主观能动性。我们不仅要适应环境，我们还要战胜环境。战胜空间，甚至战胜时间。而战胜环境、时间、空间靠的是什么？我认为是人类文明的发展。\r\n\r\n人作为一个生物个体，死后，留下了什么？思考这个问题，有助于把握自己人生的大方向。我认为主要两点：后代（你的复制体），个体文明（你是否改变了世界）。个体文明的意思就是你的存在是否推动了人类文明的发展，是否改变了世界。不是说卖菜就没有改变世界，只不过改变的比较微小而已。\r\n\r\n从一定程度上说财富的分配和社会的认可应该反应了个体在这个过程中发挥的作用。传承文明靠读书教育，推动文明是在传承的基础上创新发展。从这个角度分析，如果一个国家尊师重教，尊重科学文化，发展科学文化，这个国家一定会快速崛起。。读书无用不如趁早挣钱，勤勤恳恳太累不如投机倒把，这就是一个烂泥扶不上墙的社会。\r\n\r\n思考第二个问题：人类文明的终点是什么？我们一代又一代人，成千上万年，勤勤恳恳，努力推动着人类文明向前发展。我们为什么要推动人类文明向前发展，而发展的终点又是什么？\r\n动植物的进化从大的方面来说是防止物种灭绝，从微观的方面来说就是活的更长久。古代神话中的神仙法力和地位最终比的是谁更长寿。这个可以参考中国古代神话两大巨著：《封神榜》《西游记》。这也反应了人类对长寿与永生的向往。长寿和永生其实就是摆脱肉体的束缚的愿望。外力逼迫人类进化，而作为具有主观能动性的生物--人类，也一直在往这个方向努力。\r\n\r\n只永生了还不够，我们需要优雅的活着。那就要发展文化。优美的音乐，平静的内心。\r\n科技和文化一直是人类文明发展的主旋律。都是为了优雅的活着。\r\n\r\n我们作为一个生命个体，在人类文明进程中有可能会看到人类文明发展到终极目标。更可能是不会看到那一天，所以适可而止，活着可能比什么都重要。我们要完成的无非两个重要任务：一个是复制自己，一个是尽努力推动文明前进一点点。其它的可能都不太重要。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(41,'如何让svn diff 出现vim的diff界面','41',1433242680,1433242827,'<!--markdown-->背景：提交修改代码的时候经常要看看这次修改了什么，这时，你可能要将你的本地文件跟snv的文件进行对比，用：svn diff 命令，但是原声的svn diff界面可能很多人看不习惯，好了，这篇blog的主题就是：如何让svn diff 出现vim的diff界面。\r\n\r\n这篇blog主要是用来备忘，话不多说直奔主题。\r\n\r\n    cd ~/.subversion/\r\n\r\n这里面有个config的配置文件    \r\n\r\n修改config配置文件：\r\n\r\n    diff-cmd = *****/diffwrap.sh\r\n\r\n\r\ndiffwarp.sh是svn自带的，不想找就直接copy吧：\r\n\r\n      #! /bin/bash\r\n      \r\n      # for svn diff: 修改~/.subversion/config，找到如下配置行：\r\n      # diff-cmd = diff_program (diff, gdiff, etc.)\r\n      # diff-cmd = ~/bin/diffwrap.sh\r\n      \r\n      # 参数大于5时，去掉前5个参数；参数小于5，失败，什么也不做\r\n      shift 5\r\n      \r\n      # 使用vimdiff比较\r\n      vimdiff \"$@\"\r\n\r\n\r\n接下来你用：\r\nsvn diff yourfile \r\n就会唤起vim的diff界面了。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(154,'unix高编 chapter2 Unix Standardization','154',1443439020,1448211763,'<!--markdown-->第二章主要讲unix的标准。将此内容放到第二章讲，应该是为后面的内容奠定风格和基础。\r\n1、机构与标准\r\n为了增强unix系统的的可移植性，众多的国际组织争相制定标准。下面罗列重要组织和标准。\r\n|机构|标准|\r\n|----|-----|\r\n|ANSI(American National Standards Institute：美国国家标准协会)| ISO C|\r\n|IEEE(Institute of Electrical and Electronics Engineers：电气和电子工程师协会)|POSIX|\r\n|Open Group|Single UNIX Specification|\r\n|美国政府|FIPS(Federal Information Processing Standard)\r\n\r\n2、unix系统实现\r\n|机构|系统|\r\n|----|----|\r\n|AT&T unix 实验室|SVR4|\r\n|加州伯克利计算机系统研究组|BSD、FREEBSD|\r\n|Linus Torvalds GUN|linux|\r\n|apple|Mac OS X|\r\n|sun|Solaris|\r\n\r\n3、限制\r\n（1）编译时限制（例如，短整型的最大值是什么）\r\n（2）运行时限制（例如，文件名有多少个字符）',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(40,'内观','40',1433058240,1433064012,'<!--markdown-->引子\r\n--\r\n\r\n哈弗公开课里面有一门很热的课程：《幸福公开课》。我上了几节，其中很多内容都忘记了，现在回想，印象最深刻，最让我认同的一个观点是：幸福是一种能力。\r\n\r\n幸福\r\n--\r\n\r\n我们一生都在追求幸福，很多人可能连幸福是什么都没有搞清楚。幸福是惊喜吗？彩票中大奖？向女神表白成功？率领国足勇夺世界杯？我认为这都是不是幸福，这是喜悦或者惊喜。[幸福的百科][1]定义：幸福是指一个人的需求得到满足而产生喜悦快乐与**稳定**的心理状态。这里稳定和需求得到满足是与（&&）的关系。缺一不可，或者说更重要的是稳定。\r\n\r\n继续上面的例子，如果你向心仪女神表白成功，幸福感陡增，喜悦与满足感爆表。持续了一段时间的热恋后你可能会发现女神的追求者让你苦恼不已，女神的日常消费让你入不敷出，女神对你的高要求让习惯了过屌丝生活的你如坐针毡。接下来你的幸福感与日俱减，最后回归正常值。\r\n\r\n如果你彩票中奖，矮穷挫转身成矮富挫。没关系，起码你富了。幸福感爆棚。过上了有钱人的生活，后来慢慢的，有钱已经成为了你的预期，有钱的你让你看到了更大的世界，激发你更多的欲望，欲望得不到满足，你幸福感日趋回落，最后回归正常值。\r\n\r\n这里多次说到了正常值，是的，这个**正常值**才是现在说的重点。生活中剧烈的感官和心理刺激（无论正面的还是负面的）占据了非常少的部分，我们的生命大部分时候是平淡无味的。也就是说大部分时间都处在这个正常值。偶尔的波动都是暂时的。这个正常值决定了一个人的幸福程度，而这个正常值缺因人而异。我相信紧密围绕在伟大领袖金三胖周围的朝鲜人名的幸福指数就不一定比自认为文明开化、思想open、视野开阔的你低。有钱人也不一定就比乞丐幸福。\r\n\r\n我们一生都在追求幸福，通过以上分析（姑且认为上面分析是客观理性的），我们发现可能决定一个人是否幸福的并不是外在因素，是你自己。\r\n\r\n竟然是自己？那么什么是自己？这个问题可是三大哲学问题（你是谁，从哪来，到哪去）之一。\r\n\r\n自己\r\n--\r\n\r\n我们初略探讨下我是谁？你是这一摊肉吗？你唏嘘的胡茬，丰满的肚腩能代表你吗？或许能代表一些，如果你不再邋遢，开始健身，变得身材修长，面如德华这个人还是你吗？也还是。我经常想象未来文明，如果把我们身体所有的神经，记忆都能解析转换成数据，传递到一个地方，再把这些数据导入到一个全新的人造肉体中，这个全新的你是你吗？我认为还是。多说一句，如果上面的假想实现，我们人类就可以摆脱肉体，穿梭时空了，起码我们可以以光速旅行。\r\n\r\n邋遢的你，俊美的你，全新肉体的你都还是你。这个你共同点是你的精神没怎么大变，不同点是你的肉体发生了很大的变化。\r\n邋遢的你=邋遢+精神\r\n俊美的你=俊美+精神\r\n全新的你=全新+精神\r\n\r\n我们上面分析：邋遢的你，俊美的你，全新肉体的你都还是你。所以：\r\n邋遢的你 = 俊美的你 = 全新的你\r\n也就是说：\r\n邋遢+精神 = 俊美+精神 = 全新+精神\r\n约掉精神：\r\n邋遢 = 俊美 = 全新\r\n\r\n这得出的结论是如果你的精神层面没有变化，你的外表或者说你的肉体对你的定义影响不大。并不能决定你的存在。这么说你的精神才是真正能决定你的关键点。\r\n可能你通过健身，意志力提高你不再是那个懒惰贪吃的你，你的精神也发生了变化，是的,也是精神的变化最终改变了你。\r\n\r\n**你就是你的精神**。这里所说的精神包括你的感知，认知，记忆等。这不是典型的唯心主义吗？我们不是一直学习辩证唯物主义长大的么?我思故我在？\r\n\r\n我有点心慌，这个结论对吗？我苦思冥想（别笑我，有时候人也应该认真点、轴点）后，惊喜发现上面的叙述是有漏洞的。上面所有的描述都是静态描述，或者说是个三维的描述。我们生活的世界起码是个4维世界，还有时间。时间是一直变化的，时间的变化会让你的身体发生变化，你的精神意识发生变化，你根本就不是1秒前的你。我们自己每分每秒都在变化，就在你读我这篇碎碎念的时候，你已经受到了我的影响，或许是思考，或许是厌烦，你已经发生了变化。\r\n\r\n**你就是你不断变化的内在精神**。经过分析，我们好像又离真相进了一步。\r\n\r\n如何追求幸福\r\n------\r\n\r\n你追求幸福=你的内在精神追求幸福。\r\n再换算一下幸福变量：\r\n你追求幸福=你的内在精神追求需求得到满足而产生喜悦快乐与**稳定**的心理状态。\r\n再去除下不太重要的修饰：\r\n你追求幸福=你的内在精神追求喜悦与稳定的心理状态\r\n心理状态是不是内在精神？当然是！\r\n恍然大悟，幸福其实就是我们自己的一部分。\r\n\r\n既然幸福就是我们自己，追求幸福就是随着时间的流逝，我们不但改变自己的内在，增强自己的幸福部分就可以了。\r\n\r\n问题又来了，你可以控制你的内在精神吗？你可以控制自己不想什么，想什么吗？大部分人控制不了。连自己都控制不了，很多人比如屌丝程序员我还整天想着改变世界，可笑。\r\n\r\n我们的注意力，我们的思维其实是发散的，每个人的发散程度不一样，很多人就好像一只野马，信马由缰，发散联想能力特别强，有些人可能差点，想一只野猪，东冲西撞。发散联想能力赋予了我们创造力，但是如果它是一直野马，不受理智控制，就会被人的任性弱点控制。你信马由缰的是时候牵着缰绳的是贪婪、季度、暴力、性色。你可以试着控制下你的精神，比如坐下，不动，心里想一个东西，就想着一个东西，不发散，不转移，你试试20分钟你会转移多少次？\r\n\r\n好吧，刚才说的才是本次blog的真正目的，其实刚才那个试验就是禅修的一个方式。通过这种方式，我们可以逐步控制住我们的精神，内在精神不被我们的弱点指引，我们的创造力就会被激发，幸福接踵而至。王阳明当年格物致知的时候对着竹子发呆（格竹），其实就是在练习控制自己的注意力，从而控制自己的内在。\r\n\r\n想正确改变自己，迎接幸福，请格物。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  [1]: http://baike.haosou.com/doc/5339893-7594212.html',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(48,'【翻译】如何写php扩展','48',1436717700,1443439339,'<!--markdown-->如果代码和注释不一致，那么两者可能都是错的 --Norm Schryer\r\n\r\n\r\n<!--more-->\r\n\r\n1、简介\r\n----\r\nphp拥有非常多的扩展是它如此流行的一大原因。不管开发人员需要什么功能，他都可以在php中找到。php的扩展囊括了数据库、图形处理、压缩、xml技术等功能。\r\n\r\nphp从php3版本的突破性进展就是引入了扩展API（extension API），从而开发人员或者开发社区可以非常容易的开发php扩展。现在，2个版本后的php5.5（作者写这本书的时候php版本是5.5），\r\n扩展api跟php5.3还是非常相似。php扩展的主要是思想是对php扩展开发人员尽量隐藏zend引擎和php内核的内部机制，从而开发人员只需要了解api就可以对php进行扩展。\r\n\r\n自己开发php扩展的原因主要有2个：\r\n\r\n - 你需要一个功能，但是php并不支持。对于这种需求一般会引入一个C库，php扩展充当一个c库到php的桥梁作用。比如有一种新型数据库需要向市场推广，你需要开发一个php扩展调用c库来通过php操作这个数据库。如果你分享你的扩展，整个php社区就都可以通过php操作这个新数据库了。\r\n - 为了性能或者某种功能原因你需要用C来实现你的你的业务逻辑。\r\n\r\n如果这两个需求你都没有，你可以不用看这篇文章了。\r\n\r\n本文将会教会你如果写一个简单的php扩展，并且可以让这个php扩展引用外部的扩展库。本文对于一个想写php扩展的开发人员来说已经包括了足够的资料。学习编程最好的办法是让事情变得足够简单，一旦你了解了基础，你就可以非常容易的通过阅读网上的文档、参加技术讨论去丰富你的知识。本文就是这样安排的。\r\n所以本文主要是着力于让你快速入门。我们将会用ext_skel这个unix脚本按照扩展接口定义文件生成一个扩展框架。所以说你需要在unix上来生成扩展框架。windos开发者可以通过ext_skel_win32.php来代替unix上的ext_skel。但是本文接下来都是基于unix来进行编译php及其扩展。不过所有的扩展API介绍对于unix和windos都是一样的。\r\n\r\n你阅读完本文你将会学会如何：\r\n\r\n - 编写一个拥有简单业务逻辑的扩展\r\n - 编写一个引用C库的php扩展。特别是一些标准C文件操作函数，比如fopen()。\r\n\r\n2、快速开始\r\n------\r\n本节不会对php脚本引擎的编译模块娓娓道来，而是直接开发一个php扩展。所以说不用担心你不能很快的看到php扩展开发的全景。\r\n\r\n想象你正在开发一个web系统，但是你需要一个函数重复一个字符串N次。用php实现这个功能非常简单：\r\n\r\n    function self_concat($string, $n)\r\n    {\r\n    	$result = \"\";\r\n    	for ($i = 0; $i < $n; $i++) {\r\n    		$result .= $string;\r\n    	}\r\n    	return $result;\r\n    }\r\n\r\n执行结果：\r\n\r\n    self_concat(\"One\", 3)\r\n    returns\r\n    \"OneOneOne\"\r\n    \r\n    self_concat(\"One\", 1)\r\n    returns\r\n    \"One\"\r\n\r\n想象下，如果你要频繁的调用这个函数，并且传入的字符串特别长，并且重复的次数特别多。这就意味着你将会进行很多次的长字符串连接，并且会多次分配内存申请。这一切都会导致程序运行变慢。如果一次性申请一个足够大的内存空间，然后进行n次字符串拼接，这样就不用多次申请分配内存了，程序运行速度也会提高很多。通过扩展就可以实现上面的想法。\r\n\r\n创建php扩展的第一步是编写一个函数定义文件来声明你的扩展想要实现的函数。从而我们需要在函数定义文件中添加一行关于self_concat()函数原型声明语句：\r\n\r\n    string self_concat(string str, int n)\r\n\r\n函数定义文件的格式是一个函数定义一行。你可以指定可选参数和广泛的php类型变量，比如bool, float, int, array 等。保存文件为myfunctions.def。该文件放在php源码树中的ext/目录下面。接下你可以运行php扩展框架生成工具了。这个工具叫做ext_skel，位于ext/目录下。在php源文件目录下有个README.EXT_SKEL文件对该工具有更详细的介绍。假设你的函数定义文件是myfunctions.def并且你的扩展名字叫myfunctions，你可以用下面的命令来构建扩展框架：\r\n\r\n    ./ext_skel --extname=myfunctions --proto=myfunctions.def\r\n\r\n运行后就会在ext目录下创建一个myfunction文件夹。接下来你要做的第一件事应该是编译框架以备实际编写和测试C代码。有两种方法编译扩展：\r\n\r\n - 当做一个可加载的模块的方式或者DSO(dnymically shared object)\r\n - 静态的编译进php\r\n\r\n本文采用第二种方式，因为第二种方式更简单一些。如果你对将你的扩展编译为可加载模块感兴趣，你可以参考下位于php源码文件中的README.SELF-CONTAINED_EXTENIONS。为了让你的让你的扩展可以编译，你必须编辑它的config.m4文件。该文件位于/ext/myfunctions/目录下。因为你没有打包任何C库到你的扩展中，所以你只需要在php的编译系统中添加--enable-myfunction的配置开关（如果你想打包C库，你需要--with-extension配置开关指定C库的路径）。你可以通过去掉下面自动生成的2行的注释来打开开关：\r\n\r\n    PHP_ARG_ENABLE(myfunctions, whether to enable myfunctions support,\r\n    [ --enable-myfunctions Include myfunctions support])\r\n\r\n接下来运行php源码根目录的./buildconf生成新的configure脚本。你可以通过configure --help来查看没有function配置选项。\r\n\r\n    [root@localhost php-5.6.0]# ./configure --help| grep myfunctions\r\n      --enable-myfunctions           Enable myfunctions support\r\n\r\n现在你可以重新运行你的configure脚本，运行的时候添加你想要的配置，当然别忘了--enable-myfnction开关：\r\n\r\n    ./configure --enable-myfunctions\r\n\r\n最后通过make命令rebuild你php就可以了。\r\n\r\n    <?php\r\n        print confirm_myfunctions_compiled(\"myextension\");\r\n    ?>\r\n\r\n运行这个脚本会输出下面类似的信息：\r\n\r\n    Congratulations! You have successfully modified\r\n    ext/myfunction/config.m4. Module myextension is now compiled into PHP.\r\n\r\n另外，ext_skel脚本还生成了一个myfunctions.php脚本，你同样可以运行这个脚本来验证你的扩展是否成功编译进了php。它会给你展示一个你的扩展支持的函数列表。\r\n\r\n现在你已经成功将你的扩展编译进php，是时候真正开始programing你的self_concat函数了。\r\n下面是ext_skel脚本生成的改函数的代码片段：\r\n\r\n     PHP_FUNCTION(self_concat)\r\n      {\r\n          char *str = NULL;\r\n          int argc = ZEND_NUM_ARGS();\r\n          int str_len;\r\n          long n;\r\n      \r\n          if (zend_parse_parameters(argc TSRMLS_CC, \"sl\", &str, &str_len, &n) == FAILURE)\r\n              return;\r\n      \r\n          php_error(E_WARNING, \"self_concat: not yet implemented\");\r\n      }\r\n\r\n\r\n该自动生成的php函数的注释是用来做文档生成和代码折叠用的。改函数被定义成了可以被zend引擎识别的PHP_FUNCTION()这种函数原型形式函数也分成了参数获取和自身逻辑两个部分。\r\n\r\n使用zend_parse_parameters()函数来接收传递过来的参数。该api的原型是:\r\n\r\n    zend_parse_parameters(int num_args TSRMLS_DC, char * type_spec, ...)\r\n\r\n第一个参数代表了参数的数量。通常该参数可以通过ZEND_NUM_ARGS()宏来传递。这个宏就代表了传递至PHP函数的参数数量。第二个参数是是否线程安全，通常传递TSRMLS_CC宏就可以了，这个宏的具体含义后面再细述。第三个参数是一个string类型的变量，代表了你期望得到的变量类型列表，接下来的若干变量必须是该类型。因为php是弱类型动态语言，当定义好类型后，如果传入的类型如果不是期望的类型，就会被强制转换成期望的类型。比如，如果用户传参过来的是integer类型变量，但是你期望是个浮点型变量，zend_parse_parameters()函数将自动将改integer类型变量转换成浮点型的。如果传入的变量类型不能转换成期望的类型（比如integer转换成array），一个warning将会触发。\r\n\r\n下表罗列你可以定义的类型列表。为了完整起见，一些我们没有讨论的类型也包括其中。\r\n\r\n|类型描述符|对应的C类型|描述|\r\n|---------|---------|-----|\r\n|l|long|有符号整形|\r\n|d|double|浮点型|\r\n|s|char *, int|字符串及其字符串长度|\r\n|b|zend_bool|0/1|\r\n|r|zval *|resource类型（文件描述符，数据库链接等）|\r\n|a|zval *|键值对数组|\r\n|o|zval *|对象类型|\r\n|O|zval *|特殊对象类型，需要你将传递对象类型|\r\n|z|zval *|不需要做任何操作的zval|\r\n\r\n\r\n我们的示例中，zend_parse_parameters()对于基本类型接收的类型是原生C类型而不是zval容器类型。为了让zend_parse_parameters()函数可以修改你传入的变量，你需要以引用的方式传入。\r\n\r\n让我们看一下self_concat()函数：\r\n\r\n    if(zend_parse_parameters(argc TSRMLS_CC, \"sl\", &str, &str_len, &n) == FAILURE)\r\n    	return;\r\n\r\n注意到生成的这段代码是用来检测zend_parse_parameters函数是否返回FAILURE（SUCCESS代表了成功）。如果返回FAILURE就直接返回。上面说过，如果参数获取失败，只是抛出一个warning。因为你的函数需要接受一个string和一个integer参数，这里的“sl”就表示了这两个参数的类型。s也就是string需要两个参数：字符串本身和字符串长度。所以我们向zend_parse_parameters传递了一个char * 变量一个int变量(str和str_len)。一般情况下，用str_len来接收字符串长度，这样可以保证你的函数是二进制安全的。不用用strlen()或者strcpy()这种函数在获得字符串后进行计算字符串长度是因为这样不能保证二进制安全。所谓二进制字符串就是一个字符串中包含null。二进制格式包括了图像文件、压缩文件、可执行文件等等。\r\n“l”只需要一个参数，所以我们可以传递变量n的引用。\r\n\r\n尽管为了可读性，脚手架程序对于所有的C变量命名都明确表明了其代表的意思。我们在平时的coding中也要保持这种优良的习惯。\r\n回到参数转换规则。下面的3个对self_concat调用将会得到相同的结果。对于str、str_len和n得到参数也是一致的。\r\n\r\n    self_concat(\"321\", 5);\r\n    self_concat(321, \"5\");\r\n    self_concat(\"321\", \"5\");\r\n\r\nstr将会成为“321”，str_len等于3，而n等于5。\r\n\r\n在我们继续编写代码链接字符串并返回结果给php前，我们需要先搞清楚2个重要知识点：内存管理和php内核返回结果api。\r\n\r\n**内存管理：**\r\nphp内存操作的api跟C的标准api基本是一一对应的。具体罗列如下:\r\n\r\n    emalloc(size_t size);\r\n    efree(void *ptr);\r\n    ecalloc(size_t nmemb, size_t size);\r\n    erealloc(void *ptr, size_t size);\r\n    estrdup(const char *s);\r\n    estrndup(const char *s, unsigned int length);\r\n\r\n到这里，很多熟悉C语言的开发者可能会想：什么？strndup()在标准C中有吗？estrndup()是唯一的一个php特有的函数。他的功能类似于estrdup()，但是你可以指定你想复制的字符串（没有null）的长度。从而，这是二进制安全的。相对于estrdup()，estrndup()更推荐使用。\r\n\r\n几乎在任何情况下，你都应该用这些函数，而不是使用它们对应的C标准函数。虽然有一些特殊情况（比如你需要持久化你申请的内存）你必须用malloc()，但是除非你知道你在干什么，否则你应该总是使用这些e开头的zendapi。如果你将不是用这些函数而是C标准函数分配的内存传递给zend引擎，php引擎将会崩溃。\r\n\r\n使用zendapi提供的这些函数的一大优点就是当请求结束的时候，无论你是否释放这些内存资源，系统都会释放。所以不容易出现内存泄露的情况。但是，不要依赖这个机制。无论是调试还是线上都应该保证你申请的内存都得到了释放。\r\n使用zenndapi的另外优点包括：在多线程环境会有更高的性能、可以在debug模式发现内存错误等等。\r\n还有一点需要注意的是：如果内存分配失败会直接跑出E_ERROR，没有返回值。所以内存分配的返回值不是null。\r\n\r\n**php函数返回值：**\r\n\r\n扩展api提供了丰富的宏来方便设置函数返回值。这些宏可以分成两个流派：1、RETVAL_TYPE:返回但是继续执行你下面的C程序。2、RETURN_TYPE:返回并结束。\r\n\r\n第一种往往用在你想在把控制权交给引擎前做一些类似于清理的工作的地方。当你结束了你的清理工作，通过”return；“语句返回给php。第二种相对来说更加流行。它设定好返回类型后立刻就将控制权交给php引擎。\r\n下表罗列了相关的宏：\r\n|返回并立刻退出|返回并不退出|函数返回值|\r\n|-------------|----------|------|\r\n|RETURN_LONG(l)|RETVAL_LONG(l)|Integer|\r\n|RETURN_BOOL(b)|RETVAL_BOOL(B)|boolean(1/0)|\r\n|RETURN_NULL()|RETVAL_NULL()|Null|\r\n|RETURN_DOUBLE(d)|RETVAL_DOUBLE(d)|浮点数|\r\n|RETURN_STRING(s, dup)|RETVAL_STRING(s, dup)|如果dup是1引擎就会用estrdup复制s，并使用它，dup=0就直接使用s|\r\n|RETURN_STRING(s, l, dup)|RETVAL_STRING(s, l, dup)|l表示了s的长度，其它同上。但是这个函数会性能比较高，因为它知道了s的长度|\r\n|RETURN_TRUE|RETVAL_TRUE|返回true，注意：这个宏定义没有括号|\r\n|RETURN_FALSE|RETVAL_FALSE|同上|\r\n|RETURN_RESOURCE(r)|RETVAL_RESOURCE(r)|resource引用|\r\n\r\n\r\n**完成self_concat()**\r\n现在我们已经懂得了如何申请内存和如何返回值，所以现在开始完成self_concat():\r\n\r\n    PHP_FUNCTION(self_concat){\r\n        char *str = NULL;\r\n        int argc = ZEND_NUM_ARGS();\r\n        int str_len;\r\n        long n;\r\n    \r\n        char *result;\r\n        char *ptr;\r\n        int result_length;\r\n    \r\n        if (zend_parse_parameters(argc TSRMLS_CC, \"sl\", &str, &str_len, &n) == FAILURE)\r\n            return;\r\n    \r\n        result_length = str_len * n;\r\n    \r\n        result = (char *)emalloc(result_length + 1);\r\n    \r\n        ptr = result;\r\n    \r\n        while(n --){\r\n            memcpy(ptr, str, str_len);\r\n    \r\n            ptr += str_len;\r\n        }\r\n    \r\n        *ptr =\'\\0\';\r\n    \r\n        RETURN_STRINGL(result, result_length, 0);\r\n    \r\n    }\r\n\r\n现在唯一剩下的就是重新编译php。完成后，你就成功完成了你第一个php扩展函数。\r\n下面我们做一个测试：\r\n\r\n    <?php\r\n    ini_set(\"memory_limit\", \'256M\');\r\n    \r\n    $start = microtime_float();\r\n    self_concat(\"i have a dream one day\", 10000000);\r\n    $end = microtime_float();\r\n    print \"扩展cost:\". ($end - $start);\r\n    echo \"\\n\";\r\n    \r\n    $start = microtime_float();\r\n    php_self_concat(\"i have a dream one day\", 10000000);\r\n    $end = microtime_float();\r\n    print \"原生cost:\". ($end - $start);\r\n    echo \"\\n\";\r\n    \r\n    \r\n    \r\n    function php_self_concat($str, $n){\r\n        $result = \'\';\r\n        for($i=0; $i<$n; $i++){\r\n            $result .= $str;\r\n        }\r\n        return $result;\r\n    }\r\n    function microtime_float(){   \r\n        list($usec, $sec) = explode(\" \", microtime());\r\n        return ((float)$usec + (float)$sec);\r\n    }\r\n\r\n输出结果：\r\n\r\n    [root@localhost tests]# php test.php \r\n    扩展cost:0.23267292976379\r\n    原生cost:2.0339200496674\r\n    [root@localhost tests]# php test.php \r\n    扩展cost:0.21547794342041\r\n    原生cost:1.9321241378784\r\n    [root@localhost tests]# php test.php \r\n    扩展cost:0.20647001266479\r\n    原生cost:1.8058288097382\r\n    [root@localhost tests]# php test.php \r\n    扩展cost:0.19944787025452\r\n    原生cost:1.9643130302429\r\n\r\n可见，在字符串较长重复链接次数非常多的时候，扩展的性能是用php实现的10倍左右。\r\n\r\n**例子总结**\r\n我们已经学习了如何写一个简单的php扩展函数。回到文章开头，我们提到了开发php扩展的2个动机。第一个是为了性能或者功能，我们用C扩展来实现一些代码或者逻辑。上一个例子应该已经教会我们如何开发一个这种扩展。第二个动机是引入一个第三方类库。接下来我们就开始展开这个问题。\r\n\r\n引入第三方库\r\n------\r\n\r\n在这节，我们将学习如何编写一个完整的php扩展。该扩展引入一个C库，并且介绍如何编写一个包括多php扩展函数的php扩展。\r\n\r\n**动机：**\r\n引入第三方C库应该是最司空见惯的php扩展类型。引入的可能是数据库类库（比如mysql或者oracle）、xml类库、图像处理类库等等。这一小节我们将写一个这样的扩展。\r\n\r\n我们还是用脚手架工具来生成扩展代码骨架，这样可以省去很多工作。我们即将开发的这个扩展将会引入标准C函数：fopen(), fclose(), fread(), fwrite()和feof()。扩展将会引入一个虚拟类型--resource来表示一个打开的文件。可以发现大多数的扩展都通过resource来描述数据库链接或者文件句柄，这是因为php引擎不能直接识别这些类型。我们将要在php中实现的C中对应的api包括如下：\r\n\r\n    FILE * fopen(const char * path, const char * mode);\r\n    int fclose(FILE *stream);\r\n    size_t fread(void * ptr, size_t size, size_t nmemb, FILE *stream);\r\n    size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\r\n    int feof(FILE *stream);\r\n\r\n我们将会实现一个简单易用并且符合php风格的php函数版本。如果你要在开源社区贡献代码，你应该让你的代码更符合php命名规范和风格，而不是C的。在php源码根目录中有个CODING_STATARDS文件，里面介绍了部分php规范与约定。php很早的时候就已经实现了这几个函数，但是它的命名规范不是php风格是C风格。你可以看到你的php中有：fopen、fclose、fread、fwrite和feof等这几个函数。所以，我们要实现符合php风格的php函数。\r\n\r\n所以我们的函数定义生命文件ｍyfile.def的函数声明如下：\r\n\r\n    resource file_open(string filename, string mode)\r\n    bool file_close(resource filehandle)\r\n    string file_read(resource filehandle, int size)\r\n    bool file_write(resource filehandle, string buffer)\r\n    bool file_eof(resource filehandle)\r\n\r\n接下来，用脚手架生成初始程序骨架:\r\n\r\n    ./ext_skel --extname=myfile --proto=myfile.def\r\n\r\n接下来按照以往的例子生成你的新扩展。编译的时候在用到FETCH_RESOURCE宏的地方会遇到一些错误，为了可以初步编译，你可以先注释掉这些代码。\r\n\r\n**Resources**\r\n\r\nResources是一个虚拟类型，它可以hold住所有的类型信息。就像前面所说，这里面包括文件句柄，数据库链接等一些复杂的类型。想象一下如果你调用mysql_connet连接了mysql数据，但是当你不再使用数据库的时候并没有关闭着个连接，这样就会造成资源浪费。在php的resource机制中，当资源不再使用的时候就会被清理，至少是在请求结束的时候（通常情况下可能会更早）。有了这个安全机制后，就不会发生资源泄露的情况。如果没有这个机制，可能在一些少量请求后，webserver就会泄露很多资源，最后导致服务崩溃。\r\n\r\n**注册resource类型**\r\n\r\n改如何使用resource呢？zend引擎提供了一个相对容易的方式来使用resource。使用resource第一件要做的是先在zend引擎那注册你要使用的resource类型。api是：\r\n\r\n    int zend_register_list_destructors_ex(rsrc_dtor_func_t ld, \r\n        rsrc_dtor_func_t pld, char *type_name, int module_number);\r\n\r\n这个函数会返回一个该resource类型的id，你必须将这个id存入你扩展的全局变量中，以后再调用相关resource操作函数的时候需要用到它。ld（last destroy）是这种类型的资源在销毁的时候的回调函数。pld用于那些在本次请求并不会销毁的持久化资源类型，本文暂不讨论这种资源类型。type_name是资源类型名字。module_number是引擎内部使用的一个参数，我们调用这个函数的时候只需要传递一个已经定义好的module_number变量就可以了。回到我们的例子:我们将把下面的代码写入myfile.c源文件中。它包括传入资源类型注册函数zend_register_list_destructors_ex的资源销毁函数。这个函数要加到源文件靠前的位置。\r\n\r\nstatic void myfile_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC){\r\n    \r\n}\r\n\r\n\r\n\r\n| 函数定义宏        | 描述           |\r\n| ------------- |:-------------:|\r\n|PHP_MINIT_FUNCTION()|该函数为模块的初始函数。PHP启动阶段zend引擎会调用该函数。一般执行一些初始化工作，比如注册资源类型、注册INI值等操作。|\r\n|PHP_MSHUTDOWN_FUNCTION()| 模块关闭函数通常在php关闭的时候调用，做一些模块关闭的清理工作。比如清理模块启动时占用的资源。|\r\n|PHP_RINIT_FUNCTION()| 在php接受请求前调用的函数，通常运行一些每个进程都需要执行的逻辑|\r\n|PHP_RSHUTDOWN_FUNCTION()|php对请求处理完成返回是调用的函数，通常用来清理每个请求在开始的时候申请的资源。|\r\n|PHP_MINFO_FUNCTION()|模块信息函数是phpinfo()调用的函数，用来输出模块的信息。|\r\n\r\n\r\n\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(42,'shell 数组常用操作总结','42',1434003900,1434004056,'<!--markdown-->数组声明\r\n----\r\n普通：\r\n\r\n    arrayname=(a b c d)\r\n\r\n键值对（关联数组）：\r\n\r\n    declare -A arrayname\r\n    arrayname=([mao]=1 [hua]=2 [hu]=3 [deng]=4)\r\n\r\n使用数组\r\n----\r\n访问数组：\r\n    \r\n     arrayname[index]    #取单个值\r\n     ${!array[*]}	 #取关联数组所有键\r\n     ${!array[@]}	 #取关联数组所有键\r\n     ${array[*]}	 #取关联数组所有值\r\n     ${array[@]}	 #取关联数组所有值\r\n     ${#array[*]}        #关联数组的长度\r\n     ${#array[@]}	 #关联数组的长度\r\n\r\n\r\n遍历数组\r\n----\r\n\r\n    for i in ${arrayname[@]}\r\n    do\r\n        echo $i;\r\n    done\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(43,'任务计划','43',1434357900,1440046573,'<!--markdown-->think before you leap!\r\n三思而后行！\r\n知己知彼，百战不殆！\r\n\r\n\r\n<!--more-->\r\n\r\n\r\n连续3个感叹句，就是说明计划的重要性。如果一个计划的执行过程中朝秦暮楚，那一定是个失败的计划。\r\n\r\n什么是计划？新华字典里面的定义是：工作或行动以前预先拟定的具体内容和步骤。\r\n这里着重要说的二个字是：**具体**。不具体，都不能称为计划。\r\n复杂的任务一定要做非常具体的计划。\r\n\r\n以前我一直认为计划可有可无，就算有计划，也不一定就能按照计划执行。其实这是偏见，没有按计划执行，说明计划考虑不够全面。\r\n\r\n我认为计划至少包括：目标，步骤，支出。这里的支出包括时间支出和人力支出。\r\n\r\n首先目标：目标应该有总体目标，每个阶段的目标，每个步骤的目标。有了目标才不会迷失方向。\r\n\r\n步骤：步骤要尽可能的详细具体，每个步骤的具体方案选择，技术实现，可能遇到的问题，都要想清楚。不想好就直接大刀阔斧干，看似简单直接，其实可能你已经在走弯路了，当弯路通向了死胡同还好，大不了返工重做。要是因为弯路把系统搞的不健壮，不安全，后患无穷。\r\n\r\n支出：我认为这个是最重要的内容。为什么？因为你的领导最关系的是这个项目的支出。你需要多少时间完成。不经过深思熟虑的计划做出的deadline承诺往往比较靠前。因为你觉得自己很给力，你也希望别人觉得你很精干。\r\n假设一个项目给领导说2,3天就可以完成。可是当真正开始做的时候发现事情远远没有你想的那么简单，由于没有详细的计划，可能还绕不少弯路，2天到期后，boss来问进度，你给领导承诺7天可以完成，中间可能还会插入一个特别紧急的事情需要你处理，又耽误2天，后来又发现还需要跟另外一个人合作完成，先不说这个人是否会立马支持你，光交流时间，连调时间就够喝一壶的了。最后可能2,3天的承诺2,3周才兑现。你想想你的boss是不是已经对你无语了。对你的评价肯定是极其不靠谱，能力也不行。可是你这2,3周可一直焦头烂额，天天加班呀。\r\n反过来，如果你接到一个很重要的任务后，对任务的所有细节都考虑清楚，给你的boss一个2周的预算。然后详细给他解释为什么2周，中间有哪些工作量，哪些坑。你的boss不但可以了解这个工作的难度，还会觉得你考虑周全，思维缜密。\r\n同样一个2周的项目，有计划和没计划完全是天壤之别。\r\n\r\n再次重申，复杂的工作，请做详细的计划。\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(46,'nginx错误日志格式','46',1435646100,1443439549,'<!--markdown-->**nginx的错误日志格式到底是哪里定义的呢？**\r\nnginx的错误日志在源码里面定义的：src/core/ngx_log.c\r\n\r\n**有没有配置的地方？**\r\n好像没有\r\n\r\n**错误日志的每个字段都是什么意思？**\r\nYYYY/MM/DD HH:MM:SS [LEVEL] PID#TID: *CID MESSAGE\r\nPID：进程id\r\nTID：线程id\r\nCID：链接号\r\nMESSAGE：错误信息',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(27,'MongoDB数据文件内部结构','27',1427014500,1427026990,'<!--markdown-->有人在Quora上提问：MongoDB数据文件内部的组织结构是什么样的。随后10gen的工程师Jared Rosoff出来做了简短的回答。\r\n\r\n\r\n每一个数据库都有自己独立的文件。如果你开启了directoryperdb选项，那你每个库的文件会单独放在一个文件夹里。\r\n\r\n\r\n数据库文件在内部会被切分成单个的块，每个块只保存一个名字空间的数据。在MongoDB中，名字空间用于区分不同的存储类别。比如每个collection有一个独立的名字空间，每个索引也有自己的名字空间。\r\n\r\n\r\n在一个块中，会保存多条记录，每条记录是BSON格式的，记录与记录之间通过双向链表进行连接。\r\n\r\n\r\n索引数据也存在数据文件中，不过索引是被组织成B Tree结构，而不是双向链表。\r\n\r\n\r\n对每个数据库，有一个命名空间文件，用于保存每个名字空间对应的元数据。我们通过查询这些元数据来找到对应的名字空间的存储块位置。\r\n\r\n\r\n如果你开启了jorunaling日志，那么还会有一些文件存储着你所有的操作记录。\r\n\r\n\r\n下面图片摘自10gen工程师Mathias Stearn在MongoSV2011大会上的发言稿，手绘的数据文件结构。\r\n\r\n**1.每个数据库有相应的数据文件和命名空间文件**\r\n![][1]\r\n**2.数据文件从16MB开始，新的数据文件比上一个文件大一倍，最大为2GB**\r\n![][2]\r\n**3.文件使用MMAP进行内存映射，会将所有数据文件映射到内存中，但是只是虚拟内存，只有访问到这块数据时才会交换到物理内存。**\r\n![][3]\r\n![][4]\r\n**4.MongoDB的数据文件映射到内存表中的位置**\r\n![][5]\r\n![][6]\r\n**5.使用32位机器的话，内存地址最大可以标识4GB内存**\r\n![][7]\r\n![][8]\r\n**6.但是在32位机器上，4GB内存会有1GB被内核战用，大约0.5GB会用于mongod进程的stack空间，只剩下大约2.5GB可用于映射数据文件。**\r\n![][9]\r\n![][10]\r\n![][11]\r\n**7.在64位机器上则最多可以表示128TB的空间**\r\n![][12]\r\n![][13]\r\n![][14]\r\n\r\n**8.每个数据文件会被分成一个一个的数据块，块与块之间用双向链表连接**\r\n![][15]\r\n![][16]\r\n**9.在名字空间文件中，保存的是一个hash table，保存了每个名字空间的存储信息元数据，包括其大小，块数，第一块位置，最后一块位置，被删除的块的链表以及索引信息**\r\n![][17]\r\n![][18]\r\n**10.这些位置通过DiskLoc数据结构进行存储，存储了数据文件编号和块在文件中的位置**\r\n![][19]\r\n![][20]\r\n![][21]\r\n![][22]\r\n**11.对每一个块来说，其头部包含了一些块的元数据，比如自己的位置，上一个和下一个块的位置以及块中第一条和最后一条记录的位置指针。剩下的部分用于存储具体的数据，具体数据之间也是通过双向链接来进行连接。**\r\n![][23]\r\n![][24]\r\n![][25]\r\n**12.下面是B Tree的存储结构和工作原理**\r\n![][26]\r\n![][27]\r\n![][28]\r\n![][29]\r\n![][30]\r\n![][31]\r\n![][32]\r\n![][33]\r\n![][34]\r\n\r\n最后补充我自己画的电子版图：\r\n![虚拟内存空间][35]\r\n![mongdb文件存储][36]\r\n\r\n\r\n  [1]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_1.jpg\r\n  [2]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_2.jpg\r\n  [3]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_3.jpg\r\n  [4]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_4.jpg\r\n  [5]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_5.jpg\r\n  [6]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_6.jpg\r\n  [7]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_7.jpg\r\n  [8]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_8.jpg\r\n  [9]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_9.jpg\r\n  [10]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_10.jpg\r\n  [11]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_11.jpg\r\n  [12]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_12.jpg\r\n  [13]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_13.jpg\r\n  [14]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_14.jpg\r\n  [15]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_15.jpg\r\n  [16]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_16.jpg\r\n  [17]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_17.jpg\r\n  [18]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_18.jpg\r\n  [19]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_19.jpg\r\n  [20]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_20.jpg\r\n  [21]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_21.jpg\r\n  [22]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_22.jpg\r\n  [23]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_23.jpg\r\n  [24]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_24.jpg\r\n  [25]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_25.jpg\r\n  [26]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_26.jpg\r\n  [27]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_27.jpg\r\n  [28]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_28.jpg\r\n  [29]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_29.jpg\r\n  [30]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_30.jpg\r\n  [31]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_31.jpg\r\n  [32]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_32.jpg\r\n  [33]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_33.jpg\r\n  [34]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_34.jpg\r\n  [35]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_m1.png\r\n  [36]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_图片3.png',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(28,'Source Insight下载及注册码','28',1427080560,1427794847,'<!--markdown-->下载地址：http://www.sourceinsight.com/down35.html\r\n注册码（亲测可用）：SI3US-205035-36448\r\n\r\n常用操作：\r\n----\r\n\r\n**source insight调整字体大小：**\r\n\r\n\r\n在Option里的Document Option（ALT+T）\r\n左边有个Screen Font，点进去就可以设置了\r\n\r\n**显示文件全路径：**\r\n\r\n\r\nOptions -> Preferences -> Display -> Trim long path names with ellipsis 的钩去掉\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(29,'image.jpg','image-jpg',1427472428,1427472428,'a:5:{s:4:\"name\";s:9:\"image.jpg\";s:4:\"path\";s:35:\"/usr/uploads/2015/03/1575104836.jpg\";s:4:\"size\";i:152128;s:4:\"type\";s:3:\"jpg\";s:4:\"mime\";s:10:\"image/jpeg\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',34),(30,'image.jpg','image-jpg-1',1427472429,1427472429,'a:5:{s:4:\"name\";s:9:\"image.jpg\";s:4:\"path\";s:35:\"/usr/uploads/2015/03/3843296991.jpg\";s:4:\"size\";i:190180;s:4:\"type\";s:3:\"jpg\";s:4:\"mime\";s:10:\"image/jpeg\";}',2,1,NULL,'attachment','publish',NULL,0,'1','0','1',34),(31,'image.jpg','image-jpg-2',1427472429,1427472429,'a:5:{s:4:\"name\";s:9:\"image.jpg\";s:4:\"path\";s:35:\"/usr/uploads/2015/03/1618450288.jpg\";s:4:\"size\";i:175087;s:4:\"type\";s:3:\"jpg\";s:4:\"mime\";s:10:\"image/jpeg\";}',3,1,NULL,'attachment','publish',NULL,0,'1','0','1',34),(32,'image.jpg','image-jpg-3',1427472429,1427472429,'a:5:{s:4:\"name\";s:9:\"image.jpg\";s:4:\"path\";s:35:\"/usr/uploads/2015/03/3119011160.jpg\";s:4:\"size\";i:197910;s:4:\"type\";s:3:\"jpg\";s:4:\"mime\";s:10:\"image/jpeg\";}',4,1,NULL,'attachment','publish',NULL,0,'1','0','1',34),(34,'碎碎念','34',1427614380,1427709776,'<!--markdown-->2015/3/29\r\ncoding alone \r\nmusic and tea are my silence partners\r\nheart deep in the logic without noise\r\nwithout life noise without..\r\nfinger with music melody， word with mind rhythm\r\nlet me sucked in it\r\n2015/3/30\r\nless speaking more thinking\r\nless superficial less anxiety less impetuous\r\nsharp eyes ko endless talking\r\n',0,1,NULL,'post','private',NULL,0,'0','0','0',0),(35,'php性能调优之xhprof的应用','35',1427860140,1439888259,'<!--markdown-->概述\r\n--\r\n\r\nxhprof是facebook开发一个可以跟踪你的php服务各个环节，各个函数耗费系统资源、执行时间的php扩展。是业界系统性能跟踪利器。\r\n\r\nxhprof的安装\r\n---------\r\n\r\nxhprof的安装跟普通php扩展安装没有什么区别:\r\n\r\n    #下载源码\r\n    #git clone https://github.com/phacility/xhprof.git\r\n    #上面的版本没有修复xhprof对php5.5的bug，鸟哥的版本是没有问题的，信鸟哥。\r\n    git clone https://github.com/laruence/xhprof.git\r\n    #安装扩展\r\n    #我们clone的目录里面包含例子工具等文件夹，真正的源码在extension目录下面\r\n    cd xhprof/extension/\r\n    /usr/local/php/bin/phpize \r\n    ./configure\r\n    make\r\n    sudo make install\r\n    #查看是否将so文件copy到扩展目录\r\n    ll  /usr/local/php/lib/php/20090626/\r\n    #修改php.ini注册xhprof扩展\r\n    sudo vim /usr/local/php/etc/php.ini\r\n    #在php.ini中添加：\r\n    extension=xhprof.so\r\n    xhprof.output_dir= /home/**/data/xhprof\r\n    #创建存放临时data的目录\r\n    mkdir -p /home/**/data/xhprof\r\n    #查看xhprof扩展是否安装成功\r\n    php -m | grep xhprof\r\n\r\n    #安装Graphviz（将XHProf的分析报告以程序的函数调用图来展现）\r\n    sudo yum install graphviz\r\n    \r\n    #最后别忘了重启php-fpm\r\n    sudo service php-fpm restart\r\n    \r\n\r\n\r\n\r\n脚本性能分析\r\n------\r\n\r\nbin目录下面是一个xhprof的命令行工具，可以直接用它来分析一个php脚本的性能。代码非常简单，如下：\r\n\r\n    #!/usr/bin/env php\r\n    <?php\r\n    \r\n    // Profile a CLI script.\r\n    \r\n    if ($argc < 2) {\r\n      throw new Exception(\'usage: xhprofile <script>\');\r\n    }\r\n    \r\n    $__xhprof_target__ = $argv[1];\r\n    \r\n    $argv = array_slice($argv, 1);\r\n    $argc = count($argv);\r\n    \r\n    xhprof_enable();\r\n    require_once $__xhprof_target__;\r\n    $xhprof_data = xhprof_disable();\r\n    \r\n    var_dump($xhprof_data);\r\n\r\n比如现在我们写一个样例脚本:test.php\r\n\r\n    <?php\r\n    function ab($a){\r\n            echo $a;\r\n    }\r\n    print_r(123);\r\n    var_dump(123);\r\n    ab(100);\r\n执行：\r\n\r\n    ./xhprofile test.php\r\n\r\n结果：\r\n\r\n      .....\r\n      [\"run_init::bin/test.php==>var_dump\"]=>\r\n      array(2) {\r\n        [\"ct\"]=>\r\n        int(1)\r\n        [\"wt\"]=>\r\n        int(6)\r\n      }\r\n      [\"run_init::bin/test.php==>ab\"]=>\r\n      array(2) {\r\n        [\"ct\"]=>\r\n        int(1)\r\n        [\"wt\"]=>\r\n        int(8)\r\n      }\r\n     ......\r\n\r\n其中：ct是调用多少次的意思，wt是用了多少时间的意思。\r\n\r\nweb端性能分析\r\n--------\r\n复制：\r\n1、xhprof_html，xhprof_lib到webroot下面\r\n2、创建header.php内容如下：\r\n\r\n    <?php\r\n    if(extension_loaded(\'xhprof\')){\r\n        //载入下载的XHPROF包中的2个文件夹\r\n        include_once \'xhprof_lib/utils/xhprof_lib.php\';\r\n        include_once \'xhprof_lib/utils/xhprof_runs.php\';\r\n        xhprof_enable(XHPROF_FLAGS_CPU + XHPROF_FLAGS_MEMORY);\r\n    }\r\n\r\nxhprf+nginx有时会出现502错误。修改方法：\r\n将 \r\n\r\n    xhprof_enable(XHPROF_FLAGS_CPU + XHPROF_FLAGS_MEMORY);\r\n\r\n修改为\r\n\r\n    xhprof_enable(XHPROF_FLAGS_NO_BUILTINS | XHPROF_FLAGS_CPU | XHPROF_FLAGS_MEMORY);\r\n\r\n就可以了。\r\n\r\n3、创建foot.php 内容如下：\r\n\r\n    <?php\r\n    if(extension_loaded(\'xhprof\')){\r\n        $ns = \'myXhprof\';\r\n        //关闭profiler\r\n        $xhprofData = xhprof_disable();\r\n        //实例化类\r\n        $xhprofRuns = new XHProfRuns_Default();\r\n        $runId = $xhprofRuns->save_run($xhprofData, $ns);\r\n        //前端展示库的URL\r\n        $url = \'http://df.onebox.so.com/xhprof_html/index.php\';\r\n        $url .= \'?run=%s&source=%s\';\r\n        //变量替换\r\n        $url = sprintf($url, $runId, $ns);\r\n        //输入URL\r\n        echo \'<a href=\"\'.$url.\'\" target=\"_blank\">result</a>\';\r\n    }\r\n\r\n4、打开你要测试的页面，修改如下：\r\n\r\n    include_once \'header.php\';\r\n    //脚本原来的内容开始\r\n    .....\r\n    //脚本原来的内容结束\r\n    include_once \'foot.php\';\r\n\r\n这一步要注意，脚本中间不能exit，不然foot.php就执行不了了。\r\nxhprof效果图如下\r\n![xhprof效果图][1]\r\n\r\n参数分析\r\n----\r\n其实很简单：\r\n\r\n - Function Name：方法名\r\n - **Calls**： 调用次数\r\n - Calls%：调用次数占总调用次数的百分比\r\n - Incl. Wall Time (microsec) ： 花费时间（毫秒）\r\n - IWall%： 花费时间占总时间的百分比\r\n - Excl. Wall Time (microsec)： 不包括子函数调用本函数花费的时间\r\n - **EWall%**：不包括子函数调用本函数花费的时间占总时间的百分比\r\n - Incl. CPU (microsecs)： 占用cpu时间\r\n - ICpu%：占用cpu时间占总时间的百分比\r\n - Excl. CPU (microsec)： 不包括子函数调用占用时间\r\n - **ECPU%**：不包括子函数调用占用时间百分比\r\n - Incl.MemUse(bytes):内存占用，单位byte\r\n - **IMemUse%**： 内存占用百分比\r\n - IPeakMemUse%： 内存占用峰值百分比\r\n\r\n我认为最重要的几个参数是：**ECPU%>Calls>EMemUse%**\r\n其中**calls**如果特别多，就要看看是不是这个函数滥用了。如果**Ewall%**比较大，就要看看是io多还是计算多，是否可避免。如果**ECPU%**大，看看能不能简化逻辑。\r\n\r\n\r\n\r\n\r\n  [1]: http://7vzu8r.com1.z0.glb.clouddn.com/xhprof.png',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(25,'[翻译]MongoDb 架构（MongoDb Architecture）','25',1426929720,1443439653,'<!--markdown-->NOSQL最近成为了一个炙手可热的话题（作者发表在2012年，话说对于现在来说，NOSQL已经如火如荼了）。大规模架构的web服务开发中对于高扩展性和半结构化数据的要求推动着数据库往NOSQL方向转变。最近几年已经有了不少NOSQL数据库解决方案。我在过去的blog中（不是我的blog，[作者blog挺卡的][1]）[已经介绍过基于分布式系统理论的NOSQL][2],同时也介绍了一些挺好的产品，比如CouchDB和CassanDra/HBase。\r\n\r\n\r\n上周五，我非常幸运的在一个技术会议上见到了10gen的Jared Rosoff。我们俩对于MongoDB的技术架构做了一些探讨，我觉得我们聊得东西挺有价值的，所以在这里贴出来分享给大家。\r\n\r\n首先MongoDb的易用性和底层架构的易懂性让我非常吃惊。下面是一些简单的管理命令--开启和关闭MongoDb server。\r\n\r\n    #安装MongoDB\r\n    mkdir /data/lib\r\n    \r\n    #开启 server\r\n    .../bin/mongod #这个时候数据就存储在了/data/db那\r\n    \r\n    #开启命令行shell\r\n    ..../bin/mongo\r\n    >show dbs\r\n    >show collections\r\n    \r\n    #删除collection（删除表）\r\n    >db.person.drop()\r\n    \r\n    #通过命令行shell关闭mongod server\r\n    >use admin\r\n    >db.shutdownServer()\r\n\r\n\r\n译者注：其实启动mongod可以用 -f conf.txt这种模式启动，启动的参数放到conf.txt中比如\r\n\r\n    #配置启动参数conf.txt\r\n    dbpath=....my_work_space/mongodb01/dbs \r\n    logpath=...my_work_space/mongodb01/logs/mongod.log \r\n    bind_ip=127.0.0.1 \r\n    directoryperdb=true \r\n    port=10001\r\n    \r\n    mongodb01/bin/mongod -f conf.txt\r\n\r\n相对于关系型数据库的主要不同点\r\n---------------\r\nmongodb相对于关系型数据库的主要不同点如下:\r\n\r\n - 不同与关系型数据库的数据扁平化数据格式（2维的数据格式），mongodb的表（collection）是可以嵌套的，是多维的。也就是说mongodb的表里面可以嵌套子表、数组、哈希表等。\r\n - 不同于关系型数据库中存储在表中的数据必须是全部格式统一，mongodb的collection可以插入任意格式的数据。\r\n - mongodb查询没有join操作。鼓励不墨守成规的组织数据，保持数据一致性的重任交给了程序员。\r\n - mongodb没有事物（transaction）这一说。原子性只保持在了document（可以理解为一行）级别。也就是说不可能出现更新一行的时候更新不完整的情况。\r\n - mongodb没有隔离（isolation）,client端读取的任何数据都有可能已经被并行的client修改过了。\r\n\r\n通过去除掉这些传统关系型数据库支持的特性后，mongodb可以更轻量级、更灵活的完成大数据处理。\r\n\r\n查询处理\r\n----\r\n\r\nmongodb属于一种面向文档的数据库。在查询处理模块中，数据被组织成了JSON文档，存储在集合（collection）中。其中，collection 相对于传统RDBMS（关系型数据库）世界中的表。\r\n\r\n下面是一些简单示例：\r\n#创建一个document 并且把它插入到一个collection中\r\n\r\n    >p = {firstname:\"dave\", lastname: \"ho\"}\r\n    >db.person.save(p)\r\n    >db.person.insert({firstname:\"ricky\", lastname: \"ho\"})\r\n    \r\n    #列出一个collection中所有的document\r\n    >db.person.find()\r\n    \r\n    #用游标遍历结果\r\n    >var c = db.person.find()\r\n    >p1 = c.next()\r\n    >p2 = c.next()\r\n\r\n    #按条件查询：\r\n    >p3 = db.person.findone({lastname:\"ho\"})\r\n\r\n    #只返回部分属性（field）\r\n    >db.person.find({lastname:\"ho\"}, {fistname:true})\r\n\r\n    #删除记录\r\n    >db.person.remove({firstname:\"ricky\"})\r\n\r\n总所周知，为了加快查询速度，我们需要索引。mongodb中，索引是按照B树的数据结构存储的（不用说，mongodb自然是支持范围查询的）。 如果document本身就是树结构，对应的索引也相应的变成一个路径的模式，并且会深入到document中的深层嵌套。\r\n\r\n    #为一个collection创建索引\r\n    db.person.ensureIndex({firstname:1})\r\n\r\n    #查看所有的已经存在的索引\r\n    >db.person.getIndexs()\r\n    \r\n    #删除索引\r\n    >db.person.dropIndex({firstname:1})\r\n    \r\n    #索引可以建立在一条document路径上\r\n    >db.person.ensureInde({\"address.city\":1})\r\n    \r\n    #可以创建联合索引\r\n    >db.person.ensureIndex({lastname:1, firstname:1})\r\n\r\n\r\n索引也可以创造在复合类型的属性上，比如数组。这样的话，数组的每个元素都会在BTree上创建一个独立的节点。\r\n\r\n构建索引有两种模式：前台模式，后台模式。前台模式构建索引相对来说会更快一些，但是构建索引的时候数据库是不能被访问的。如果系统运行在relica set（下面会介绍）上，比较推荐的方式是轮流下线各个子数据库，然后采用前台模式分别构建索引。\r\n\r\n当查询的时候有多个查询项，并且没有相对应的复合索引，mongodb会选用一个最优的单索引（相对于复合索引）查询获得一个候选集，然后线性遍历候选集来匹配其他查询项。\r\n\r\n当一个collection有多个索引可以选用的时候，当第一次执行一类查询时，mongodb会创建一个并发执行方案（也就是并发执行所有可用的索引），直到最快的索引方案执行完毕（其它慢的也就不用再执行了，哪个方案最快已经比出来了）。最快方案的执行结果就会返回，同时系统会记住这个最快的索引。接下来，如果还有同类型的查询，系统就会自动用这个最快的索引进行查询，直到这个collection发生了比较大的改动，系统会按照同样的方法重新计算最优索引。\r\n\r\n当一个collection索引比较少时或者只要单列索引时，查看对这个collection的常用查询条件、排序条件，然后创建更好的复合索引也是非常重要的。当然，索引也不是越多越好，保持索引也是需要耗费系统性能的。因为当更新、插入、删除记录时，首先要操作索引。为了保持一个最优的索引性能，我们需要定期评估创建或者保持高效索引，删除低效索引。\r\n\r\n存储模型\r\n----\r\nmongodb是用c++实现的。它维护了一个内存映射表（译者注：实际上是用的mmap技术，将数据文件通过mmap映射到虚拟内存，用到的时候载入物理内存）直接将硬盘上的文件映射到一个内存中的字节数组。每个collection存储在namespace文件(namespace文件在系统中的后缀是.ns，它包含一些元数据)和extent数据文件中。\r\n![][3]\r\n\r\n这里采用了双向链表技术，每个collection的数据都组织成了一个链式extent，每个extent代表了一块连续的磁盘空间。每个extent包含了一个doc链的头尾指针。doc链中每个doc通过指针相连，每个doc中包含的数据采用了BSON格式编码。这里doc可以认为是一条记录（document）。\r\n\r\n在数据发生改变的地方，为了防止数据改变时增加的内存空间超过了原有分配的空间，整条记录（record）将会被移到一个有额外空间的大一点的区域。这些额外空间就是用来作为一个增长缓存，这样将来数据增长的时候就不用再挪动数据了。额外空间的大小是经过对每个collection的修改统计动态调整的。另外，挪动数据后，原来的数据空间将会被释放，他们会按照大小放到一个空闲链表里面。\r\n\r\n我们可以想象到，经过对数据对象的增加、删除、修改，将会产生很多数据空洞。这些碎片的存在将会使每次磁盘io读/写更少的数据。所以，我们需要一种紧凑技术（周期性的执行紧凑命令）来拷贝数据到一块连续的存储区域中。当然这种紧凑操作必须在offline的时候做。典型的做法是轮换着每次下线一个relica set（副本集），并分别对其进行紧凑。\r\n\r\n索引是用B树实现的。每个B树节点包含若干个key，同时有个指针指向左孩子B树节点。\r\n译者注：关于mongodb数据文件存储见另外一篇blog：[MongoDB数据文件内部结构][4]\r\n\r\n数据更新和事物（transaction）\r\n--------------------\r\n下面是更新一条记录的操作：\r\n\r\n    var p1 = db.person.findone({lastname: \"ho\"})\r\n    p1[\"address\"] = \"san jose\"\r\n    db.person.save(p1)\r\n    \r\n    #单然，也可以一句命令搞定！\r\n    db.person.update({lastname:\"ho\"}, {$set:{address:\"san jose\"}}, false, true)\r\n\r\n这种更新操作默认是不等待的（像飞出去的箭一样，管他命中不命中~）。当然，mongodb提供了等待的选项，客户端可以在更新前对这次操作配置为等待修改结果返回，比如可以设置为等待到写入硬盘，或者等待到已经确认这条修改已经扩散到各个副本server上。mongodb提供了一种非常精致的方法来搞定这一切。首先它为每个replica set 设置一个标签，这样用户就可以根据自己的需求要为每个表个性化的设置更新模式。\r\n译者注：\r\n为了方便理解，译者罗列下php的sdk支持的几种[更新类型][5]。\r\n![][6]\r\n\r\n在关系型数据库中，可串行性（Serializability）是一个非常核心的概念。在并发执行时，多个线程对数据库的操作都好像是被按照顺序组织在了一个序列中一个一个的执行。所以每个客户端都可以认为自己是独占数据库的。底层数据库对这个功能的实现是靠锁机制或者多版本技术来提供这种隔离性的。但是这个概念在mongodb（包括很多其他NOSQL）是被无视的。\r\n\r\n在mongodb中你读取的每条数据都只能当初他之前得一个快照，也就是说就在你对着你查询到的这条数据发呆的时候，它的本体也就是存在数据库中的样子已经被其他人修改过了。所以说，如果你想根据一条数据在数据库中本来大小的基础上修改它，当你提交修改请求的时候，你要修改的那条数据可能已经改变了。（比如你读到的是10，想加1，提交11的时候，可能它在数据库中已经被其它人改成12了）。如果对于你的应用程序来说这是不可以接受的，你不许在发送修改命令的时候再校验一次，看看是不是还是10。\r\n在这种模式下，当你方式修改请求的时候回额外发送一个状态用来被服务端校验，从而服务端在执行你的修改请求前会根据你提交的状态进行一次校验，通过了才会执行修改。当然，服务端进行校验修改的2次操作是具有原子性的。在mongodb中，你可以通过调用“findAndModify”方法完成这个操作。\r\n\r\n    var account = db.bank.findone({id:1234})\r\n    var old_bal = account[\'balance\']\r\n    var new_bal = old_bal + fund\r\n    \r\n    #状态校验会放到查询条件里面\r\n    db.bank.findAndModify({id:1234, balance:old_bal}, {$set:{balance:new_bal}})\r\n    \r\n    #校验上次命令是否执行成功\r\n    var success = db.runCommand({getlasterror:1,j:true})\r\n    \r\n    if(!success){\r\n        #重试\r\n    }\r\n\r\n事物这个概念在mongodb中也是被无视的。mongodb会暴走对于每个document的操作是原子的（也就是说不会出现一条记录只部分更新的情况）。但是如果更新涉及到多个document，mongodb就不会保证对多条document的操作符合原子性了。\r\n\r\n所以，对于操作多条记录并保证其原子性的重任就落到了程序开发人员身上。接下来，将描述一个设计模式用来实现这个功能。这个技术不只针对于mongodb，其它可以保证单条记录原子性的NOSQL数据库都可以用它来保证更新多条数据的原子性。\r\n最基础的想法就是创建一个新的document（我们可以叫它事物transaction）将所有你想更新的文档存储到里面。然后在你想更改的文档里面存储transaction文档的id。然后小心的设计一个执行序列，一个个的更改各个要更改的文档和transaction文档，最后我们就可以达到更改多个文档并保持原子性的目的。\r\n![][7]\r\n译者注：下面解释下这个图表。\r\n第一步：\r\n创建一个新文档Tran1，并将要更新的文档存到Tran1中。Tran1的status设置为init。这一步操作完成后如果失败了（**这里的失败译者认为不是操作数据库失败，应该是应用程序出现了异常，如果是操作数据失败可以用getlasterror获得，然后重新操作一次数据库就可以了。而下面的恢复操作应该是在catch代码块执行的操作**）恢复一致性的时候：扫描所有状态为init的transaction走第二步。（这一步创建Tran1其实是一个原子操作，它只是新插入了一条记录）。\r\n第二步：\r\n遍历transaction中的所有doc，添加一个指向transaction的属性。如果这一步完成后应用程序失败，继续扫描状态为init的transaction，然后将改transaction中的doc遍历添加指向该transaction的属性。\r\n第三步：\r\n将transaction的状态标记为pending。如果这一步完成后应用程序失败，扫描所有状态为pending的transaction，查询是否有指向该transaction的doc，如果没有了，说明第四步已经完成，就更改状态为commited。如果还有，就继续执行第四步。\r\n第四步：\r\n对transaction的doc分别执行更新操作（当然这里每个doc的更新是能保证原子性的）。如果这一步执行的时候出现失败的情况，就扫描状态为pending的transaction，如果还有doc执行该transaction，就继续执行第四步，如果没有了（就是说都修改完成了）就删除掉这个transaction。译者认为也可以将transaction的状态标记为committed。\r\n第五步：\r\n当所有doc指向该transaction的时候（就是说都修改完成了），修改transaction的状态为committed。这个时候这个transaction已经执行完毕，并且保证了修改多条的原子性。\r\n\r\nmongodb的官方网站上也有一个类似的[技术][8]可以解决mongodb没有transaction的问题，这两个的思想概念基本一样，实现方法有略微不同。\r\n\r\n副本集模型（Replication Model）\r\n------------------------\r\nmongodb通过replica set 来实现其高可用性。replica set是一种在多个物理机器上通过数据冗余备份的方式来实现高可用性的。通常包括一个主库多个从库。为了保证数据一致性，所有的修改操作（包括插入、更新、删除）都操作主库，然后这些更新会异步更新到其它从库。\r\n![][9]\r\n在replica set（也就是所有的主从数据库）中，成员之间相互关联，并且相互监听别人的心跳。如果有一个从库挂了，其它库就会感应不到该库的心跳信号，从而就会从副本集中删掉它。当这个从库将来恢复的时候，他可以重新加入集群，并且从主库那里同步它挂掉这段时间的数据更新。当然，如果它挂掉的时间太长了，主库的更新log已经不能完全记录这段时间发生的数据修改，就只能重新加载所有的主库数据到这个从库了，就好像这个从库是新加入的一样。（译者注：主库会维护一个oplog来记录数据修改操作，但是这个log的大小是有限的，如果写满了就会覆盖掉最旧的log，我们这边的dba叫做写圈）。\r\n\r\n\r\n上面说的是从库挂掉，如果主库挂掉，情况就会更糟糕一些。为了防止主库挂掉后的尴尬，一个主库选举协议会一直在各个成员之间运行着，当主库挂掉，会最快的根据这个协议选举一个新的主库。各个成员选举投票的时候考虑的因素挺多，比如节点更新时间，网络等等。当一个成员获得了大多数投票，一个新的主库就产生了。需要注意的是如果主库挂掉的时候还在进行异步复制主库的操作，新选举的主库将不会获得到这些更新的信息，也就是说，会丢失掉这些信息。\r\n\r\nmongodb客户端lib会提供访问mongodb的api。在最开始，客户端会连接副本集中的一些成员（根据一个种子列表），通过向这些成员询问你是不是主库？（ismaster？）最后客户端会生成一个谁是主库谁是从库的快照。这样，当客户端执行修改操作的时候就连接主库，执行查询操作的时候就随机连个从库。同时客户端会周期性的运行ismaster命令来探测是否有新的库加入。当有已经存在的库挂掉后，所有连接它的客户端都会断掉跟它的连接，同时强制更新快照。\r\n\r\n这里有一个特殊的从库需要介绍下，他就是延时从库（slave delay）。它会让数据从主库扩散到它的时间有一个固定的延时（比如2个小时）。它的作用是当出现误删除时，可以用它的数据进行恢复。（译者注：上面讲的oplog只会记录删除的id，不会记录删除的具体内容。刚参加工作那会儿，误删除过一些数据，求救dba，dba发来oplog一看只有删除的记录，没有删除的内容，都是泪..）\r\n\r\n对于数据更新操作，客户端会将请求发到主库，默认情况下，当主库写入成功后就会返回。但是，mongodb提供了请求参数来指定当数据扩散到多少个，或者哪个从库的时候返回。具体见上面的一个表。这样客户端可以确认一条更改操作至少扩散到了多少个从库。当然，这个操作要在效率和实时性之间做权衡。\r\n\r\n对于查询请求，默认情况下，客户端可以从主库那里拿到最新的数据。客户端也可以选择指定自己读哪个从库，这个时候必须能容忍从库返回的数据有可能已经过期。查询请求读从库为mongodb提供了负载均衡的功能。需要注意的是，在读从库这种模式下，写完立刻读可能会看不到修改。\r\n\r\n对于大部分请求都是查询的应用，从库读可以极大的改善系统性能。客户端驱动会周期性的扫描各个从库，选择最快延迟最低的的从库来执行查询操作。这里需要注意的是读请求只能访问一个从库，mongodb没有群读或者多个节点读这个说法。\r\n\r\nrelica set的作用是提供数据冗余和读负载均衡。但是对于写请求来说，没有提供负载均衡，所有的写都落到主库上。\r\n\r\nrelica set的另外一个好处就是成员可以轮流下线做一些耗费性能的操作，比如紧凑操作，索引建立，数据备份等，不会影响线上服务。\r\n\r\n\r\n分片模型\r\n----\r\n为了让写请求均衡，我们可以采用mongodb的分片。分片首先要把一个表根据partition key分成多个chunk（一个chunk包括一个key区间的数据），然后将各个chunk分别分发到各个分片（每个分片都是一个replica set-副本集）。\r\nmongodb的分片让表可以扩充到无限大，这对于大数据场景非常重要。\r\n\r\n重申下，在分片模型中，每个collection都要定义一个partition key。key的空间被分成多个存储在各个shard上的chunk，每个chunk都是一段连续的key空间。\r\n![][10]\r\n译者另附一图加深理解：\r\n![][11]\r\n\r\n    #创建一个partition key\r\n    db.runcommand({shardcollection: \"testdb.person\",\r\n        key: {firstname:1, lastname:1}\r\n    })\r\n\r\n在分片的设计中，客户端lib连接一个无状态的路由server（mongos）， mongos的行为跟mongod类似。mongos作为一个路由server，在根据客户端请求的特征重定向到相应的分片server时起到异常重要的作用。\r\n![][12]\r\n对于包含partition key的插入、删除、更新请求，根据partition key找到包含这个key的chunk，根据chunk和shard的对应关系，mongos（也就是路由server，下面统一称mongos）将此请求路由到相应shard的主库上。其中shard和chunk的对应关系维护在一个config server上，当然每个server本地也会保留一个备份（并且当config发生变化，本地备份会去config server上拉取最新的配置）。partition key和chunk是m:1的关系，也就是说partition key对应唯一的一个chunk，一个chunk包含很多partition key。chunk和库也是m：1的关系。从而可以唯一确定这个chunk所在的库。\r\n\r\n对于查询请求来说，mongos会先考察partition key是selection criteria（译者注：实在不知道该怎么翻译这个东西）的一部分，mongos会把这种请求只定向到相应的shard上，由该shard上的主库或者从库服务。否则，mongos会先分发请求到各个shard上，在各个shard上分别完成查询，各个shard的计算结果将会汇总到mognos，最后返回给client。当请求需要对结果排序，并且排序的字段是partition key， mongos将会顺序的请求各个shard，client分别拿到结果就行了。如果排序的字段不是partition key，mongos将会把请求分发到各个shard上执行局部排序，然后mongos在局部排序结果的基础上进行再次合并排序。\r\n\r\n当数据插入到chunk时，如果chunk负载已经接近满负荷，我们需要分割chunk。mongs根据请求这个chunk的请求数量，对比其他shard上chunk的请求数量统计，来发现这种需要分割chunk的情况。接下来mongos会向存储这个chunk的shard主库发送分割chunk命令。这个shard的主机将会执行分割chunk，同时将这个分割点汇报给配置服务器。这里可以看到，到目前为止，chunk分割并没有发生shard之间的数据移动，所有的数据还都在原来的shard上。\r\n\r\n另外，还有一种均衡机制（运行在某个mongos上），这种机制的作用是保证每个shard上有差不多相同数量的chunk。当不均衡状态被监控到时，均衡器会向繁忙的shard发送移动chunk的命令。chunk转移将会在online进行。原始shard会联系目的方shard来初始化数据传输，接着就会进行从原始shard到目的shard数据复制。这个过程可能会持续一段时间，时间取决于数据量的大小。数据复制的时候可能会出现数据还在更新的情况，这些更新的数据会存在原始shard上，并且会被原始shard跟踪记录下来，当复制结束时，这些更新会同步到目的shard。经过多轮迭代，chunk迁移将进入最后阶段:原始shard停止对该chunk 的请求的服务。经过最后一轮更新同步，目的shard将会更新配置服务器，同时通知原始shard返回StaleConfigException给mongos，mongos从配置服务器上读取最新的配置信息，重新发送原来发给原始shard的请求。在未来的某个时间点，原始shard上的这些已经成功迁移的chunk将会物理性的永久删掉。\r\n\r\n这里也存在高频度更新的情况。chunk数据从原始shard到目的shard 复制的时候发生了大量更新操作到原始shard，并且数据更新的速度快于数据复制的速度。这种情况下，对于这个chunk的迁移将会退出。然后， mongos会接着处理其它需要迁移的chunk。\r\n\r\n\r\nMap/Reduce 的执行\r\n--------------\r\n\r\nmongodb提供了一套map/reduce框架来提供并行数据处理。mongodb map/reduce的概念跟hadoop类似。只有下面一些略微的区别：\r\n\r\n 1. mongodb 输入数据来自collection而不是hdfs目录\r\n 2. mongodb 输出可以追加到一个已经存在的collection中，而不是hdfs目录\r\n\r\nmongodb的map/reduce工作流程大概如下：\r\n\r\n 1. 客户端定义map函数，reduce函数，输入数据的查询条件，输出数据的目的collection\r\n 2. 客户端向mongos发送请求\r\n 3. mongos定向这个请求到相应的shard（发送到单个shard还是多个shard根据查询条件中是否包括partition\r\n    key）。这里要注意的是mongos会从从各个shard中选取一个server来服务，现在的版本基本都是选择主库。\r\n 4. 每个shard的主库会执行查询命令，然后将结果通过管道的形式发送给客户端定义的map函数，map函数会返回一串串键值对放到内存buffer中。当buffer满后，客户端定义的reduce函数将会执行，它会将buffer中的键值对进行归类，最后把结果存到本地collection中。注意这里reduce的只是buffer中的数据并不是最终结果。\r\n 5. 当第4步结束后，reduce函数将会在上次reduce的结果上再次reduce，合并出这个shard最终结果。\r\n 6. 当第5步执行结束后，mongos会通知相关用来存储结果collection 的shard\r\n    servers（如果输出collection不是存储在多个shard上，就只通知一个就好了，如果是多个就通知多个）。\r\n 7. 存储结果collection\r\n    shard的主库将会分别请求各个shard的前面步骤reduce的结果。当然，它只会请求它要保存的key区间。\r\n 8. 主库用从各个shard上请求的初步reduce结果再次运行reduce函数。接着本地存储这些最终结果。如果用户还定义了finalize函数，接下来就会运行。\r\n\r\n下面有一个简单的示例。该示例用来根据文档话题进行倒排。\r\n\r\n    db.book.insert({title:\"NOSQL\",\r\n                 about:[\"software\", \"db\"]})\r\n    \r\n    db.book.insert({title:\"Java programming\",\r\n                 about:[\"software\", \"program\"]})\r\n    \r\n    db.book.insert({title:\"Mongo\",\r\n                 about:[\"db\", \"technology\"]})\r\n    \r\n    db.book.insert({title:\"Oracle\",\r\n                 about:[\"db\", \"software\"]})\r\n    \r\n    db.book.find()\r\n    \r\n    m = function() {\r\n     for (var i in this.about) {\r\n         emit(this.about[i], this.title)\r\n     }\r\n    }\r\n    \r\n    r = function(k, vals) {\r\n     return({topic:k, title:vals})\r\n    }\r\n    \r\n    db.book.mapReduce(m, r, {query:{},\r\n                   out:{replace:\"mroutput\"}})\r\n    \r\n    db.mroutput.find()\r\n\r\n总得来说，我发现mongodb是一个非常强大，同事非常易用的数据库。我非常期待运用mongobd+node。js。将会我会继续分享这方面的经验。\r\n\r\n最后，非常感谢jared rosoff想我提供这么多mongodb实现细节。\r\n\r\n原文地址：[http://horicky.blogspot.com/2012/04/mongodb-architecture.html][13]\r\n\r\n\r\n  [1]: http://horicky.blogspot.jp/\r\n  [2]: http://horicky.blogspot.com/2009/11/nosql-patterns.html\r\n  [3]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_p1.png\r\n  [4]: http://blog.dufei.cc/index.php/archives/27/\r\n  [5]: http://php.net/manual/zh/mongo.writeconcerns.php\r\n  [6]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_mongo_w.png\r\n  [7]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_p2.png\r\n  [8]: http://docs.mongodb.org/manual/tutorial/perform-two-phase-commits/\r\n  [9]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_p3.png\r\n  [10]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_p4.png\r\n  [11]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_p6.png\r\n  [12]: http://7vzu8r.com1.z0.glb.clouddn.com/mongo_p5.png\r\n  [13]: http://horicky.blogspot.com/2012/04/mongodb-architecture.html',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(193,'一次time_wait故障记录','193',1448268660,1448343590,'<!--markdown-->###1、背景与现象\r\n根据调用我方服务的业务反馈，我方服务超时率升高。对方通过查看日志，发现有非常多的504错误。对方调用其他服务均正常。\r\n###2、排查过程\r\n**（1）排查点1**\r\n我方线上机器负载，内存使用率，网卡流入流出均正常。数据库亦没有报错。查看nginx access日志，没有发现异常请求，也就是说请求根本就没达到nginx，初步怀疑网络问题。\r\n**（2）排查点2**\r\n504是网关错误，是指中间代理或者网关请求其下游服务的时候超时。这里的中间代理和网关可理解为到目标服务之间的中间节点。下游服务是这个中间节点的下个节点，当然这下个节点很有可能就是你的服务。因为中间节点只是单纯转发数据包，出现问题的概率不大，更何况我们是内网请求，是中间节点的问题概率更小。\r\n为了验证是否是中间节点问题，在机房任意挑一台机器 \r\n\r\n    mtr -c 100 目标ip\r\n\r\n结果是偶尔跳帧，整体正常。\r\n这里多说一句，mtr分析网络链路问题的重要工具，他是traceroute+ping的组合体。其原理是不断发送非常低生存时间的包至目标地址机器中间节点，通过是否能收到包得响应来计算到各个中间节点的时间。该命令可以统计到中间各个节点的失败率，最小时间，最大时间，平均时间，响应时间的方差。如果方差较大，说明网络有波动。不过这个命令需要root权限才能执行。\r\n命令示例：\r\n![][1]\r\n**（3）排查点3**\r\n怀疑是否单台机器有问题导致整体服务超时，通过排查确实发现有一台机器超时非常严重，其它正常。问题已经定位到一台机器上。\r\n**（4）单台机器分析**\r\n下面对单台机器进行分析：单台机器cpu负载正常，磁盘也没有写爆（之前有过这种磁盘写爆，系统负载飙升、拒绝服务的惨痛经历）。统计tcp连接情况：\r\n\r\n    ss -at | awk \'{print $1}\' | sort | uniq -c \r\n\r\n问题出现了，发现10几万time_wait。为什么会有这么多time_wait呢。time_wait过多，会占满系统端口，导致新来的请求分配不到端口，此时服务就返回了504。\r\n\r\n**问题解决**\r\n问题渐渐明朗，是不是内核ops忘记优化了？查看/etc/sysctl.conf确实发现忘记优化了。\r\n排查发现确实：net.ipv4.tcp_tw_recycle 给设置成0了。\r\n将其设置成1，开启time_wait快速回收，问题解决。\r\n\r\n###3、time_wait是什么来路，那个tcp_tw_recycle又是何方神圣\r\n####3.1、tcp建立连接时的3次握手与结束时的4次挥手\r\n3次握手与四次挥手是说清楚time_wait相关问题的基础。过程见下图：\r\n![][2]\r\ntime_wait是在主动发起结束连接收到被动发发送fin时的状态。服务端的此连接会一直保持着，默认时间是2个msl（max segment lifetime）也就是8分钟。\r\ntcp协议之所以有这个机制原因有二\r\n1、为了防止中间有超时重发的包污染新创建的连接。示意图如下；\r\n![][3]\r\n2、如果最后一次ack丢失，远程就一直是last-ack状态，占用端口释放不了。示意图如下：\r\n![][4]\r\n\r\n通过以上分析，我们知道了time_wait的来由与作用。\r\n虽然timewait有好处，但是对于高并发的服务器来说，如果qps10000，8分钟就堆积：8x60x10000=480w的连接，这样用不了8分钟，服务器就会把端口、连接数打满。\r\nlinux内核的tcp_tw_recycle参数如果配置为1，此时timewait连接就可以被快速回收，通过修改这个参数（此参数默认是不启用 ，也就是0）可以大大的提高服务器的并发数与吞吐量。但是nat环境或者挂lvs的集群修改这个参数会有一定的概率出现问题。tcp的机制是每次请求都会带上当前时间戳，如果新来的请求时间戳小于上次的就认为着个包是过期数据包。会丢弃它。因为此时可能多台机器公用一个ip，多台机器的时间可能又不同，就会导致各种包被丢弃的混乱场面。我们的服务通过ntp自动同步时间来保证时间的一致性。所以即使用了lvs也优化了这个参数。\r\n\r\n参考文献：\r\n[不要在linux上启用net.ipv4.tcp_tw_recycle参数][5]\r\n[记一次TIME_WAIT网络故障][6]\r\n[TCP的三次握手(建立连接）和四次挥手(关闭连接）][7]\r\n[mtr:更为强大的网络连通性判断工具][8]\r\n[Linux 使用ss命令代替 netstat][9]\r\n\r\n\r\n  [1]: http://7vzu8r.com1.z0.glb.clouddn.com/time_waitmtr.png\r\n  [2]: http://7vzu8r.com1.z0.glb.clouddn.com/time_waittcp%20(2).png\r\n  [3]: http://7vzu8r.com1.z0.glb.clouddn.com/time_waitduplicate-segment.png\r\n  [4]: http://7vzu8r.com1.z0.glb.clouddn.com/time_waitlast-ack.png\r\n  [5]: http://www.cnxct.com/coping-with-the-tcp-time_wait-state-on-busy-linux-servers-in-chinese-and-dont-enable-tcp_tw_recycle/\r\n  [6]: http://huoding.com/2012/01/19/142\r\n  [7]: http://www.cnblogs.com/Jessy/p/3535612.html\r\n  [8]: http://commands.sinaapp.com/2012/11/22/mtr%E6%9B%B4%E4%B8%BA%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E9%80%9A%E6%80%A7%E5%88%A4%E6%96%AD%E5%B7%A5%E5%85%B7/\r\n  [9]: http://my.oschina.net/lionel45/blog/109779',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(74,'如何评测新系统的系统状态','74',1437632160,1448343200,'<!--markdown-->###1、系统error log评估（比如nginx错误日志，php_error_log）\r\n\r\n不要轻视任何一个warning，更不要说error了。要从warning中发现问题。\r\n我遇到的一次故障经验：\r\n**故障表现：**阶段性的出现服务返回空，初步查看没有错误日志。\r\n**追查过程：**查看warning，发现:PHP Warning:  Illegal string offset \'code\' in xxxxx。本来应该是个数组，现在确是一个字符串。如果它来自第三方，也就是个数据异常，问题不大。但是我确看到了来自配置文件的warning。\r\n**结论：**发现是共享内存没有打开写锁的情况下读出了脏数据。\r\n\r\n###2、业务error评估\r\n\r\n业务error也是非常重要的信息。可以通过观察分析业务error看出很多问题，比如数据库超时，请求第三方超时等等。\r\n\r\n###3、业务正常日志\r\n\r\n通过分析业务正常日志，可以分析业务的各个环节和子模块，关键模块是否正常运行\r\n\r\n###4、每分钟平均时间评估\r\n\r\n     grep \"?d=pc\" intf.onebox.360.cn.log | sed \'s#\\[.*/.*/\\(.*:.*:.*\\):.* +0800\\]#\\1#g\' | awk \'BEGIN{sum[0]=0;num[0]=1;}{sum[$4]+=$14; num[$4]++;}END{for( i in sum)print i \":\" sum[i]/num[i]}\' > ~/result.log\r\n\r\n该统计可以统计系统的整体服务能力和响应时间，可以和老系统进行对比，如果平均长可以是程序流程变长或者占用资源过多，或者网络有问题等等。\r\n\r\n###5、每分钟大于或者小于阈值的数量分析\r\n\r\n    grep \"?d=pc\" /data/nginx/logs/open.onebox.haosou.com/web/intf.onebox.360.cn.log | sed \'s#\\[.*/.*/\\(.*:.*:.*\\):.* +0800\\]#\\1#g\' | awk \'BEGIN{sum[0]=0;num[0]=1;all[0]=1;}{all[$4]++;if($14 < 0.005)sum[$4]++;if($14>0.2)num[$4]++;}END{for( i in sum)print i \" | \"all[i]\"-\" sum[i] \"-\" num[i]}\' > ~/result1.log\r\n\r\n该项统计非常重要，可以快速发现系统的异常请求。同时还要利用时间周期等因素辅助定位问题。\r\n下面是分析结果，可以看到2015:14:23这个时间有大量的非常短的请求，可以考虑程序异常中断或者报错等问题。经过定位发现是有请求命中放刷策略异常终止。\r\n\r\n    2015:14:18 | 4254-4-18\r\n    2015:14:19 | 4293-1-27\r\n    2015:14:20 | 4555-86-32\r\n    2015:14:21 | 4339-1-30\r\n    2015:14:22 | 4381-1-19\r\n    2015:14:23 | 5220-523-23\r\n    2015:14:24 | 5338-682-22\r\n    2015:14:25 | 5091-401-25\r\n    2015:14:26 | 4896-413-20\r\n    2015:14:27 | 4323-2-17\r\n    2015:14:28 | 4346-3-24\r\n    2015:14:29 | 4352-2-19\r\n    2015:14:30 | 4717-74-51\r\n    2015:14:31 | 4442-3-14\r\n    2015:14:32 | 4435-1-32\r\n    2015:14:33 | 4435-1-22\r\n\r\n\r\n###6、每分钟http状态码分析\r\n\r\n    grep \"?d=pc\" intf.onebox.360.cn.log | sed \'s#\\[.*/.*/\\(.*:.*:.*\\):.* +0800\\]#\\1#g\' | awk \'BEGIN{sum[0]=0;}{sum[$4\"-\"$8]++; }END{for( i in sum)print i \":\" sum[i]}\' > ~/result2.log\r\n\r\n输出结果如下，可以看到大部分情况是200，只有少数的499错误：\r\n\r\n    2015:14:02-200:4711\r\n    2015:14:02-499:1\r\n    2015:14:03-200:4708\r\n    2015:14:04-200:4472\r\n    2015:14:05-200:4350\r\n    .....\r\n\r\n###7、每分钟请求返回字节数分析：返回空分析、阈值分析、平均值分析\r\n\r\n输出结果是整个服务的最后环节，如果服务不正常，输出结果也肯定可以发现问题。如果服务的中间有环节出现了问题，可能不报错，不超时，一切都看起来正常，但是输出肯定不正常，最后通过输出字节的分布就可以发现这个问题。\r\n\r\n小结：\r\n本文讨论的很多指标都是以分钟为单位，当然以小时，天为单位的日志同样要分析关注。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(166,'关于php引用的有趣问题','166',1447297080,1448267698,'<!--markdown-->程序如下：\r\n                                                                                                                                                                                     \r\n    <?php\r\n    $a=1;\r\n    $b=&$a;\r\n    $c=(++$a)+(++$a)+(++$a); \r\n    var_dump($c); //10\r\n\r\n输出10。\r\n如果无脑分析，感觉应该是：2+3+4=9。为什么输出确是10呢？\r\n\r\nvld分析如下：php -dvld.active=1 test.php \r\n\r\n    Finding entry points\r\n    Branch analysis from position: 0\r\n    Return found\r\n    filename:       /home/dufei-xy/test/test.php\r\n    function name:  (null)\r\n    number of ops:  11\r\n    compiled vars:  !0 = $a, !1 = $b, !2 = $c\r\n    line     # *  op                           fetch          ext  return  operands\r\n    ---------------------------------------------------------------------------------\r\n       2     0  >   ASSIGN                                                   !0, 1\r\n       3     1      ASSIGN_REF                                               !1, !0\r\n       4     2      PRE_INC                                          $0      !0\r\n             3      PRE_INC                                          $2      !0\r\n             4      ADD                                              ~1      $0, $2\r\n             5      PRE_INC                                          $2      !0\r\n             6      ADD                                              ~0      ~1, $2\r\n             7      ASSIGN                                                   !2, ~0\r\n       5     8      SEND_VAR                                                 !2\r\n             9      DO_FCALL                                      1          \'var_dump\'\r\n       6    10    > RETURN                                                   1\r\n    \r\n    branch: #  0; line:     2-    6; sop:     0; eop:    10\r\n    path #1: 0, \r\n    int(10)\r\n\r\n通过vld分析，看不出什么端倪。考虑到$b=&$a，将$a和$b同时设置成了引用类型，我们画图分析如下。\r\n\r\n分析：\r\n\r\n    $a=1;//这里没有问题，如下图，在内存中给a分配一个内存块，值为1。\r\n\r\n![$a=1;][1]\r\n\r\n    $b=&$a;//这里将b指向a对应的内存块，此时a，b都是引用类型\r\n\r\n![$b=&$a;][2]\r\n\r\n    $a++;/*这里要注意，$a++等同于如下两句：$a=$a+1；$0=$a。$0是一个中间变量，\r\n    对$0赋值的时候，$0也被污染成引用类型，指向a指向的内存块，此时对应的那块内存变成了2。*/\r\n\r\n![$a++;][3]\r\n\r\n    $a++;//同上句，$2也引用指向此内存块，内存中是3。顺便说下此时$a,$b,$0,$2均是3。\r\n\r\n![$a++;][4]\r\n\r\n    ($a++)+($a++);//这里做的相加操作其实是中间变量~1=$0+$2=3+3=6,指向另外一块内存\r\n\r\n![($a++)+($a++);][5]\r\n\r\n    $a++;//此时$a,$b,$0,$2均是4\r\n\r\n![$a++;][6]\r\n\r\n    $c=(($a++)+($a++))+($a++);//~1+$2=6+4=10。此时真相已经明朗。\r\n\r\n![$c=(($a++)+($a++))+($a++);][7]\r\n\r\n这个小问题的关键点有两个：\r\n1、理解引用的传染性\r\n2、理解中间变量（$1,$2,~1）的使用。中间变量可以通过vld抓取的opcode看到。\r\n\r\n  [1]: http://7vzu8r.com1.z0.glb.clouddn.com/%E5%BC%95%E7%94%A8%E5%B0%8F%E6%B5%8B%E8%AF%951.jpg\r\n  [2]: http://7vzu8r.com1.z0.glb.clouddn.com/%E5%BC%95%E7%94%A8%E5%B0%8F%E6%B5%8B%E8%AF%952.jpg\r\n  [3]: http://7vzu8r.com1.z0.glb.clouddn.com/%E5%BC%95%E7%94%A8%E5%B0%8F%E6%B5%8B%E8%AF%953.jpg\r\n  [4]: http://7vzu8r.com1.z0.glb.clouddn.com/%E5%BC%95%E7%94%A8%E5%B0%8F%E6%B5%8B%E8%AF%954.jpg\r\n  [5]: http://7vzu8r.com1.z0.glb.clouddn.com/%E5%BC%95%E7%94%A8%E5%B0%8F%E6%B5%8B%E8%AF%955.jpg\r\n  [6]: http://7vzu8r.com1.z0.glb.clouddn.com/%E5%BC%95%E7%94%A8%E5%B0%8F%E6%B5%8B%E8%AF%956.jpg\r\n  [7]: http://7vzu8r.com1.z0.glb.clouddn.com/引用小测试7.jpg',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(173,'tcpdump和wireshark抓包追踪问题实践','173',1448171700,1448267691,'<!--markdown-->1、背景\r\n发现我方服务超时率由正常的万分之一逐步上涨至千分之二，并有逐渐上升态势。查看系统负载、上游服务（upstream server）、数据库、网络状态均正常。查看nginx access日志，发现所有的超时日志均有一个特点：request_time超时，但是 upstream_reponse_time正常。我们知道request_time表示nginx从接到请求到处理完请求，并把处理后的数据包返回给请求者所花费的所有时间;upstream_response_time指得是nginx请求其upstream server（也就是php-fpm）请求花费的时间。两者相差很大，说明phpserver服务是正常的，但是第三方请求nginx和nginx请求完php至返回结果给第三方这两个阶段可能会出现问题。这里面最有可能也最常见的情况就是网络问题。\r\n2、追查过程\r\n首先确认是否是网络链路问题，通过相互之间ping，ping主机，ping vip都正常，确认应该不是网络问题。\r\n那接下来最有可能的是nginx接收请求和发送数据有问题，或者对方接收数据有问题。对于这种问题，tcpdump+wireshark就是绝配了。\r\n\r\n下面是请求url和wireshark分析截图：\r\n\r\n    106.**.**.** - - [19/Nov/2015:15:59:02 +0800] \"GET /?d=pc&ext=&from=searcher&guid=0AAE1639BFB635BD7CA616C2D5E729BC.1433222412839&host=&huid=&ip=222.80.142.125&ls=0&map_rank=0&mid=&mso_app=&mso_from=&mso_jisu=0&mso_x=&mso_y=&netstatus=&ob_ext=&ofmt=seria&orig_q=%E5%9B%9B%E7%88%AA%E9%99%86%E9%BE%9F&osrc=https_srp&prompt=&query=%E5%9B%9B%E7%88%AA%E9%99%86%E9%BE%9F&quiet=0&s=0&scheme=https&sid=291b1a927a0b4011b28699ca6962c948&so_ob_ext=&src=hao_search&terms_weight=5Zub54iq%2C-%3B6ZmG6b6f%2C6%3B&ua=Mozilla%2F5.0%20%28Windows%20NT%205.1%29%20AppleWebKit%2F537.36%20%28KHTML%2C%20like%20Gecko%29%20Chrome%2F31.0.1650.63%20Safari%2F537.36%20QIHU%20360SE&userid= HTTP/1.0\" 200 93815 \"-\" \"-\" 647 0.876 0.096\r\n\r\n![][1]\r\n分析：灰色记录是onebox发送fin的记录。Sequenceid是93945。\r\n可以看到search机器最后一次ack是fin+1，也就是93946。表明已经收到了fin。但是接下来一直没发fin，等了很久（将近1秒）reset了这个链接。\r\n\r\n    10.**.**.** - - [19/Nov/2015:15:59:01 +0800] \"GET /?d=pc&ext=&from=searcher&guid=2871AA3240B71F17059E2B27705A66DD.1447919939653&host=&huid=&ip=219.148.36.14&ls=n252c000c9d&map_rank=0&mid=&mso_app=&mso_from=&mso_jisu=0&mso_x=&mso_y=&netstatus=&ob_ext=&ofmt=seria&orig_q=%E7%90%86%E6%83%B3%E5%9B%BD%E9%99%85%E6%95%99%E8%82%B2&osrc=srp&prompt=&query=%E7%90%86%E6%83%B3%E5%9B%BD%E9%99%85%E6%95%99%E8%82%B2&quiet=0&s=0&scheme=http&sid=fc28d879857110491e24a6b7b201c89a&so_ob_ext=&src=dlm&terms_weight=55CG5oOz%2C%2A%3B5Zu96ZmF%2C%1F%3B5pWZ6IKy%2C%1A%3B&ua=Mozilla%2F5.0%20%28Windows%20NT%205.1%3B%20WOW64%29%20AppleWebKit%2F537.36%20%28KHTML%2C%20like%20Gecko%29%20Chrome%2F31.0.1650.63%20Safari%2F537.36&userid= HTTP/1.0\" 200 99754 \"-\" \"-\" 695 1.265 0.184\r\n\r\n![][2]\r\n这个跟上个雷同\r\n\r\n    10*.**.**.** - - [19/Nov/2015:15:59:02 +0800] \"GET /?d=pc&ext=&from=searcher&guid=7680C17D1B039AE2DE4D213E763EB1A0.1421135742117&host=&huid=&ip=123.122.119.153&ls=0&map_rank=0&mid=9e035048d348a126c805ae5df7700948&mso_app=&mso_from=&mso_jisu=0&mso_x=&mso_y=&netstatus=&ob_ext=&ofmt=seria&orig_q=%E5%86%85%E6%B6%B5&osrc=https_srp&prompt=&query=%E5%86%85%E6%B6%B5&quiet=0&s=0&scheme=https&sid=c44f6ab28a5ec56d85348f8942257c62&so_ob_ext=&src=se7_drag&terms_weight=5YaF5ra1%2Cd%3B&ua=Mozilla%2F5.0%20%28Windows%20NT%205.1%29%20AppleWebKit%2F537.36%20%28KHTML%2C%20like%20Gecko%29%20Chrome%2F31.0.1650.63%20Safari%2F537.36%20QIHU%20360SE&userid= HTTP/1.0\" 200 58414 \"-\" \"-\" 627 2.482 0.080\r\n\r\n![][3]\r\n![][4]\r\n\r\n可以看到search最后一次ack是58545，也就是fin包的id+1。三种情况一致。\r\n\r\n得出结论，不是网络原因，因为我方已经发送完所有数据，而且对方对我方最后的fin也做出了回应。应该是对方服务接收处理数据有问题。\r\n对方经过排查，发现是后台程序占用资源过多引起的。\r\n\r\n\r\n  [1]: http://7vzu8r.com1.z0.glb.clouddn.com/tcp_dumpimage001.png\r\n  [2]: http://7vzu8r.com1.z0.glb.clouddn.com/tcp_dumpimage002.png\r\n  [3]: http://7vzu8r.com1.z0.glb.clouddn.com/tcp_dumpimage003.png\r\n  [4]: http://7vzu8r.com1.z0.glb.clouddn.com/tcp_dumpimage004.png\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(188,'unix高编 chapter3 FIle I/O','188',1448211780,1448267672,'<!--markdown-->1、本章首先介绍了文件描述符的概念，和几个相关函数：open, openat, close, read, write, lseek, create用法。\r\nunix系统会为每次open或者create文件或者设备的时候分配一个文件描述符（file descripter）。文件描述符大小非负，其中0，1，2分表代表标准输入，标准输出，标准错误输出。是3个特殊fd。\r\nopen和openat的区别是openat可以在一个fd的基础上用相对路径打开文件生成一个新的fd。\r\nlseek用来调整打开文件的当前读取位置。用lseek可以形成文件空洞。比如你可以跳过100M向文件中写数据，此时文件大小就变成100M+\r\n\r\n2、本章还介绍了文件共享。文件共享相对来说复杂一些，读共享主要是每个进程对于自己打开的文件要由当前读取位置。写相对来说麻烦一点。\r\n先说unix系统为了文件共享，设计的3个数据结构。分别是：process table entry, file table entry, v-node table entry。其中process table entry里面是每个进程维护自己打开的fd，同时保存了该fd只想file table entry的指针。file table entry是unix内核对每个打开的文件分配描述其相关信息的数据结构，着里面包括：文件状态，当前offset，指向v-node的指针。v-node和i-node描述了文件的相关信息，比如文件大小，文件磁盘存储位置等。示意图如下：\r\n![][1]\r\n如果两个进程同时打开了一个文件，此时的数据结构状态如下：\r\n![][2]\r\n\r\n我们可以看到，两个进程打开了同一个文件，但是生成了2个不同的文件描述符，2个不同的文件描述符对已不同的file talbe， 2个不同的file table指向了同一个v-node。\r\n如果只是读，在file table中为各自的fd记录了当前file offset，所以共享文件读是没有问题的，但是写就没这么简单了。\r\n\r\n\r\n  [1]: http://7vzu8r.com1.z0.glb.clouddn.com/unix_unix3.1.png\r\n  [2]: http://7vzu8r.com1.z0.glb.clouddn.com/unix_unix3.2.png',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(83,'memcache与memcached对比','83',1438682760,1442302104,'<!--markdown-->1、memcache与memcached概述\r\n--------------------\r\n一说起缓存后端工程师马上就会想到memcache、redis等缓冲数据库。大部分的后端架构都会用到缓存，而memcache更是普遍用于各种系统中。那memcached（注意后面多个d）是个什么东西？\r\n\r\n我们都知道memcache是cs结构，分为服务端和客户端，我们接下来分别展开说。\r\n\r\n**1.1、服务端**\r\n\r\n是不是有两种这样的缓存数据库？一个叫memcache，一个是memcached？我google了下发现并没有所谓：http://memcache.org/的官网。只有：http://memcached.org/。首先可以肯定得是memcache对于数据库来说说的都是一个东西，通过官方网站来看，感觉官方更觉得自己的产品叫memcached。\r\n\r\n服务端启动memcache其实是启动memcached这个二进制文件，比如：\r\n\r\n    /usr/local/memcached/bin/memcached -d -p 11211 -U 0 -P /var/run/memcached.pid -c 40960 -t 4 -m 15360 -u root -v\r\n\r\n其中的参数我们就不一一详述了，可以用 ./memcaced -h 查看帮助。\r\n我们看到服务端我们通过启动一个memcached的程序启动memcache，这个d的英文是daemon，意思就是常驻进程的意思。通过以上分析我们看到memcache是对这个缓存数据库的一个常用称呼，memcached是这个缓存数据库的实际运行程序。\r\n\r\n**1.2、客户端**\r\n\r\n想连接memcache必须得有客户端，memcache提供了各种各样的客户端，支持花样繁多的语言。这里主要讨论php客户端，因为php客户端很闹心的有两个memcache客户端名字，没错，他们分别是:[memcache][1]和[memcached][2]。\r\n\r\n只差一个字母，这两个客户端有什么区别呢？总体上来说他们都是一个php扩展，他们的作用都是让php通过他们连接操作memcache服务端数据库。区别是memcache是php语言内置的一个扩展，不依赖第三方类库。而memcached是基于libmemcached类库开发的php扩展，后续作者继续分享分析对这两个扩展源码解读的文章。下面会从外部对这两个php扩展进行分析。\r\n\r\n\r\n2、php扩展中memcached与memcache的对比\r\n---------------------------\r\n相对于memcached，memcache出生的更早，从而它使用的更广泛、使用的人更多。但是新出现的memcached客户端功能更丰富，更强大。下面是一个支持功能对照列表：\r\n||memcache|memcache|\r\n|------|-------|--------|\r\n|发布日期|2004-06-08|2009-01-29 (beta)|\r\n|仍在维护？|Yes|Yes|\r\n|第三方依赖|None|libmemcached|\r\n|key自动修复|Yes|No|\r\n|Append/Prepend|No|Yes|\r\n|自动序列化|Yes|Yes|\r\n|二进制协议|No|Optional|\r\n|CAS|No|Yes|\r\n|压缩|Yes|Yes|\r\n|超时设置|Connect Only|Various Options|\r\n|一致性哈希|Yes|Yes|\r\n|延迟get|No|Yes|\r\n|Multi-Get|Yes|Yes|\r\n|session支持|Yes|Yes|\r\n|指定server get/set|No|Yes|\r\n|数字存储|Converted to Strings|Yes|\r\n|支持长连接?|Yes|No|\r\n\r\n这里在着重解释几点：\r\n1、key自动修复，我们知道key不能有空格，不能超长，memcache客户端会自动对这种不符合规定的key转换成符合规定的。而memcached是直接返回false。\r\n2、存储object或者数组的时候不用序列化，客户端会帮你完成这些事情。\r\n3、二进制协议，关于二进制协议相关可以参考:[BinaryProtocolRevamped][3] [简单的文本协议、二进制协议][4]。我们知道通信协议有文本协议和二进制协议，相对于文本协议，二进制协议更安全更高效。\r\n4、超时设置。memcache只提供了连接超时设置\r\n\r\n    ini_set(\"memcache.default_timeout_ms\", 50);\r\n\r\nmemcached提供了更加丰富的设置选项，可以通过\r\n\r\n    public bool Memcached::setOption ( int $option , mixed $value )\r\n\r\n来设置。具体参数可以参考：[http://php.net/manual/zh/memcached.constants.php][5]\r\n\r\n\r\n3、memcache迁移至memcached注意事项\r\n------------------------\r\n\r\n为了系统的高效性与与时俱进，我们的线上系统要从memcache迁移到memcached。踩到的坑：\r\n1、memcache和memcached存取数组的时候是不兼容的，也就是说memcache set的数组，memcached get出来是有问题的。这时候会报一个waring：could not read long value, too big。通过memcached的源码分析可以看到：\r\n\r\n    case MEMC_VAL_IS_DOUBLE:\r\n    {    \r\n        char conv_buf [128];\r\n\r\n        if (payload_len >= 128) {\r\n            php_error_docref(NULL TSRMLS_CC, E_WARNING, \"could not read double value, too big\");\r\n            retval = -1;\r\n        } \r\n\r\nmemcache客户端set的数组在memcached读出来的时候判断成了long类型，如果数组大于128个字节，就会报”too big“ 并return。其实这个问题并不严重，miss而已，如果是个小数组，就不会miss，导致程序错误。\r\n2、默认memcached的一致性hash策略和memcache并不一致。这就是导致同样一个key会映射到不同的memcache服务端。这时候就要注意了，如果你的数据并没有设置失效时间，而是通过程序delete掉。这个时候如果你改变了客户端，就会出现永远delete不掉的问题，因为不同的客户端定位到了不同的服务器。这就产生了垃圾数据。同时，如果恰巧一个key在两个客户端都映射到了一个server，这个时候就要注意脏数据问题。啰嗦了这么多，反正就是一句话，不要让两个客户端同时工作，切换客户端的时候最好清除服务端的数据。\r\n3、迁移的时候要考虑系统缓存短暂失效是否能接受，出现问题如果回滚等一些问题。\r\n4、迁移完别忘了观察memcache服务端状态：\r\n\r\n    watch -d \"echo stats |nc 127.0.0.1 11211\"\r\n\r\n4、结论\r\n--\r\n对于客户端来说memcached更高效，功能更丰富。建议用最新的memcached。\r\n\r\n\r\n  [1]: http://pecl.php.net/package/memcache\r\n  [2]: http://pecl.php.net/package/memcached\r\n  [3]: http://code.google.com/p/memcached/wiki/BinaryProtocolRevamped#Command_opcodes\r\n  [4]: http://wanxiaotao12-126-com.iteye.com/blog/1880901\r\n  [5]: http://php.net/manual/zh/memcached.constants.php',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(100,'linux查看进程/线程状态','100',1439203260,1439208895,'<!--markdown-->查看系统各进程的状态，追踪异常进程是经常遇到的问题。\r\n有时候用top等命令查看没有大量占用cpu的进程，但是系统负载确特别高。这时候可能是某些线程占用较高的cpu。因为用top命令只能查看进程的状态，并且进程的cpu占用并不包括子线程。\r\n工欲善其事必先利其器，本篇blog将总结常用的查看进程状态的方法。抛砖引玉，本文对各个命令和工具只介绍最常用的功能，想了解更多用法可以--help、man或者google！\r\n\r\n<!--more-->\r\n\r\n##top\r\n特别要关注的指标：load（负载），idle（空闲百分比）\r\n\r\n1、top -d 刷新频率 -p pid\r\n比如 `top -d 1 -p 12345` \r\n可以以1秒的频率监控12345进程状态的变化\r\n2、top -H\r\nH 开关可以列出线程。PID将是线程ID。\r\n同时在打开top命令的情况下输入H也可以转换成线程模式。\r\n3、输入大写P，则结果按CPU占用降序排序。输入大写M，结果按内存占用降序排序。\r\n\r\n##htop\r\nhtop是功能更强大的top。界面更加炫酷，选项功能更加齐全。\r\n\r\n1、过滤功能:按F4可以触发过滤功能，只有满足过滤条件的进程或者线程才会显示出来。\r\n2、搜索功能：按F3或者/可以搜索单个进程\r\n3、自动显示进程和线程\r\n4、按大P按照cpu占用百分比排序，大M按照内存占用百分比排序\r\n5、支持鼠标点击\r\n6、按空格选中进程，按t可以列出改进程的进程树，按s可以打印strace信息（需要root权限）。\r\n\r\n##ps\r\nps可以罗列当前系统的进程信息，常用的命令选项是：`ps axuH`、 或者`ps XH pid`\r\n其中大H可以打印出相关线程信息。\r\nps命令通常和grep，xargs命令混合使用。比如杀掉所有名字是php-fpm的进程：\r\n\r\n    ps axu | grep php-fpm | xargs kill -9\r\n\r\n##pstree\r\npstree会按照树的形式打印出进程信息。常用命令选项：`pstree -anp`\r\n其中线程和进程的显示区别是：\r\n{线程名字},线程号\r\n进程名字,进程号\r\n\r\n##进程状态标识\r\n\r\n|一级标识|二级标识|描述|\r\n|----|--|---|\r\n|D||不可中断     Uninterruptible sleep (usually IO)|\r\n|R||正在运行，或在队列中的进程|\r\n|S||处于休眠状态|\r\n|T||停止或被追踪|\r\n|Z||僵尸进程|\r\n|W||进入内存交换（从内核2.6开始无效）|\r\n|X||死掉的进程|\r\n||<|高优先级\r\n||N|低优先级\r\n||L|有些页被锁进内存\r\n||s|包含子进程\r\n||+|位于后台的进程组；\r\n||l|多线程，克隆线程  multi-threaded (using CLONE_THREAD, like NPTL pthreads do)\r\n\r\n一般Sl标识的是线程。\r\nSs的是带有子进程的父进程\r\nS一般进程',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(114,'php架构优化之常用策略','114',1439209020,1443439326,'<!--markdown-->php作为最好的语言最容易受到攻击的就是它的性能问题。\r\nphp主要应用场景是业务开发，其实在我们日常业务开发中，php的性能问题在网络请求、数据库操作等io问题面前已经不值一提。在经历多次从数据库取数据、curl接口后，c实现的程序和php实现的程序耗时会在同一个数量级。\r\n另外高性能的系统是设计出来的。高性能语言、高性能数据库、高性能机器在糟糕的设计面前一样只能匍匐前进。所以我认为系统架构设计是高性能系统最重要的一环。\r\n本位旨在分享作者最近在做的系统优化经验，鉴于作者能力有限，只能管中窥豹抛砖引玉。\r\n\r\n\r\n<!--more-->\r\n##优化点分析\r\n**1、php版本升级**\r\n我们的系统php版本还是5.2。php版本在5.4之后做了大量的bug修复，php5.5更是集成了opcache，opcache想对于apc增加了代码优化功能，相对于原来的apc性能提升10%已上。提升php版本可以获得不小的收益。但是要注意的是php5.5相对于php5.2有许多变化和不兼容情况，一定要做完备的diff操作。\r\n**2、配置文件优化**\r\n系统经过多年的发展，为了提高其扩展性和配置性，已经会有非常多的配置信息。我们系统的配置信息可能有几千项，原来是吧配置文件都放到一个php文件里面，每次请求都从这个配置文件里面拿到相关配置信息。但是随着配置文件越来越大，性能问题也就变得越来越明显。\r\n首先、这几千个配置项并不是每次请求都会遇到，但是放到了一个配置文件中就只能每次请求都全部load一次。并且有些配置文件一个配置项是一个php数组，其下面有上百个子配置项。我们知道php通过hash构建php数组，如果数组的子元素过多就会频繁申请内存，计算hash，会严重影响性能。所以这里对配置文件做了以下两个维度的操作。\r\n\r\n - 把配置文件打散，简单配置项放入共享内存中，每个配置项设置200秒超时，miss再读配置文件\r\n - 把大的数组配置文件打散存入共享内存，同样200秒超时，miss再读配置文件\r\n\r\n这里的共享内存用的是yac。一开始用的是apcu这个共享内存。但是apc和php-fpm有个bug：有一定的几率导致整个apc内存被锁住，被锁住后就不能在进行写操作。解决这个bug的折中办法是关闭apc的写锁，这样即使多个进程同时更新一个php文件的缓存会导致经过这两个方面的改进，系统性能大幅度提升。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(117,'php架构优化之压测与瓶颈分析','117',1440045840,1447142699,'<!--markdown-->##1、压测\r\n####1.1、压测的意义\r\n系统开发出来，开发者需要对系统的性能做到心中有数，这里面的性能参数很多，最重要的两个参数是每秒相应数（qps）和响应时间。有了对系统的把握才能更好的分配资源，或者优化系统。\r\n####1.2、压测常用手段\r\n压测工具很多，常用的如http_load, seige, ab等等。各种工具之间大同小异。\r\n1、单个或多个服务接口压测\r\n对于简单的系统，可能只提供了若干个服务，服务接口的参数不同对系统性能消耗影响不大，这样可以将单个或多个接口配置到待压测列表中，压测工具会逐个遍历压测。\r\n这里要注意，这个压测列表不要太大，太大的话就会照成压测不均匀，导致压测结果不准确。\r\n2、复制流量压测\r\n有的系统提供非常多的服务，每个服务对性能消耗不同。或者每个服务的接口参数不同，对性能影响非常大，这样就很难利用几个接口进行压测来评估系统整体性能。这时可以采用流量复制的手段。采用gor这种流量复制工具，将线上流量实时复制到压测机器，还可以调配流量复制系数，比如2倍流量，5倍流量等。这样就能实时模拟线上情况，压测的结果也相对准确。\r\n####1.3、压测注意事项\r\n1、压测不要只注重qps或只注重相应时间。qps和响应时间是相辅相成的。一般情况下qps压的越高，此时相应时间越长，当压到响应时间根本不能接受的时候，高qps已经没有意义。所以评估系统性能要qps和响应时间达到一个平衡的状态。\r\n2、有些时候压测过程中由于系统负载过高，导致很多请求失败，或者传输不完整，逻辑失败等等，这时虽然响应很快但是已经不能正常提供服务，即使qps很高，但是很多请求都是无效请求，此时就会导致压测不准。其实还有一个参数可以发现这种情况，那就是每次请求平均响应包大小。如果服务失败一般情况下这个平均大小会变小，通过这个参数可以即使发现问题，调整压测并发。\r\n3、压测并发不能设置太大，新手动辄将并发设置成几十上百，反正是要压测极限性能，并发大点没关系。其实这是错误的。并发大了，cpu根本服务不过来，很多性能都浪费在进程调度上。上下文切换（tc）非常多，此时压测的qps会偏小，响应时间会边长。除非执行时间比较长，io比较多的服务才需要将并发设置高一些。对于响应比较快得服务，并发生设置成比核数多一些，就可以压测出相当的性能了。\r\n4、查看机器负载情况。vmstat sar top这几个命令就够了。php的话还可以看下php-fpm或者httpd的服务状态。用vmstat时第一列是当前调度队列中得等待进程数，如果这个很多，说明你压重了。\r\n\r\n##2、瓶颈分析\r\n####2.1、瓶颈分析的意义\r\n####2.2、php瓶颈分析常用手段\r\n####2.3、更好的分析方法',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(125,'unix高编 chapter1 Unix System Overview','125',1442301000,1448211718,'<!--markdown-->1.1、\r\n今天开始阅读unix环境高级编程，一天一小节。希望自己能坚持下去。\r\n1.2、\r\n主要是一个概括unix系统的一个架构图。\r\n![unix架构图][1]\r\n\r\n从里到位依次：内核，系统调用，shell、库\r\n\r\n通过观察这个图可以引申出几个问题：\r\n1、为什么要有内核态、用户态之分\r\n内核负责管理整个系统的资源，每个进程在初始化的时候内核会分配必须的资源（比如堆栈）。程序执行运算，操作堆栈不用继续申请系统资源（cpu除外），运行在用户态。但是如果程序要申请系统的资源，比如对内存，文件或者网络io等就需要由用户态切换成内核态运行。\r\n参考一篇文章：[内核态和用户态的区别 zz][3]\r\n2、什么是系统调用，为什么要有系统调用\r\n程序通过系统调用由用户态切换至内核态。内核提供系统调用方便程序进入内核态。\r\n参考一篇文章：[linux系统调用][2]\r\n\r\n1.3、\r\n此小节内容比较少，简单的介绍了登陆和shell。\r\n我想作者安排这小节应该是出于抛砖引玉，逐步展开的意图。\r\n本篇读书笔记没啥好写的，八卦下这本书的作者简历吧。\r\n**w.richard stevens(1951-1999）**\r\n国际知名unix和网络专家，受人尊敬的作家。他的著作有：《UNIX网络编程》（两卷本）、《UNIX网络高级编程》、《TCP/IP详解》（3卷本）、本书《UNIX环境高级编程》。7本不朽著作。\r\n出生于赞比亚，从头像上看应该是个欧洲后裔-白人。在美国上的大学直至获得博士学位。最终定居南非。1999年9月1日逝世。\r\n\r\n1.4、\r\n这小节有个模拟ls的代码，但是代码里面include了一个apue.h的头文件。这个头文件会用于本书的很多示例中，所以必须先编译这个头文件。\r\n方法参考：\r\n[APUE.3e 安装（基于ubuntu12.0.4）][4]\r\n但是编译的时候会报错，解决方法参考：\r\n[Linux下配置APUE的编译 报错之后如何处理][5]\r\n对于静态链接库参考：\r\n[全面剖析Linux库文件路径的添加][6]\r\n\r\n本节代码：\r\n\r\n    #include  \"apue.h\"\r\n    #include <dirent.h>\r\n    \r\n    int main(int argc, char *argv[]){\r\n        DIR *dp;\r\n        struct dirent *dirp;\r\n        \r\n        if(argc != 2){\r\n            err_quit(\"usage: ls directory name\");\r\n        }\r\n    \r\n        if((dp = opendir(argv[1])) == NULL){\r\n            err_sys(\"can\'t open %s\", argv[1]);\r\n        }\r\n    \r\n        while((dirp = readdir(dp)) != NULL){\r\n            printf(\"%s\\n\", dirp->d_name);\r\n        }\r\n    \r\n        closedir(dp);\r\n        exit(0);\r\n    }\r\n\r\n编译：gcc ls.c -o myls -l apue\r\n这里不要忘了添加-l apue，不然编译不通过。\r\n运行：./myls ~\r\n\r\n其实一开始直接用apue这个本书自带的工具包会隐藏挺多细节，但是，作为初学者，不要太过贪心，掌握好本书作者想传授的知识才是重点！\r\n\r\n1.5\r\n这一小节引出了几个概念：文件描述符、标准输入、标准输出、标准错误输出、unbuffered io、standard io。\r\n着重分析下unbuffered io 和standard io：\r\n这个buffer指的是os对输入输出是否做了缓存，也就是说输入输出是否立马执行。\r\nunbuffered io 系列函数（如：write、read、open、close等）在unist.h头文件中。该系列函数操作会立刻执行，不用flush。\r\nstandard io 系列函数（如：fget、putc、getc、gets、printf等）在stdio.h头文件中。改系列函数会把数据先存在一个本地进程的buffer空间，不立刻落地。也就是说，一个进程写一个文件，如果不调用flush函数将数据刷入磁盘文件，其它进程可能不能立刻看到该进程新写入的数据。\r\n\r\n两个例子：\r\nunbuffered io 版示例：\r\n\r\n    #include \"apue.h\"\r\n    #define BUFFSIZE 4096\r\n    \r\n    int main(void){\r\n        int n;\r\n        char buf[BUFFSIZE];\r\n    \r\n        while((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0){\r\n            if(write(STDOUT_FILENO, buf, n) != n){\r\n                err_sys(\"write error\");\r\n            }\r\n        }\r\n    \r\n        if(n < 0){\r\n            err_sys(\"read error\");\r\n        }\r\n    \r\n        exit(0);\r\n    }\r\n\r\nstandard io 示例：\r\n\r\n    #include \"apue.h\"\r\n    int main(void){\r\n        int c;\r\n        while((c = getc(stdin)) != EOF){\r\n            if(putc(c, stdout) == EOF){\r\n                err_sys(\"output error\");\r\n            }\r\n        }\r\n    \r\n        if(ferror(stdin)){\r\n            err_sys(\"input error\");\r\n        }\r\n        exit(0);\r\n    }\r\n\r\n1.6、\r\n此节介绍了进程的相关概念，最后有一个父子进程通信的示例程序。\r\npid实例：\r\n\r\n    #include \"apue.h\"\r\n    \r\n    int main(void){\r\n        printf(\"hello world from process id: %ld \\b\", (long)getpid());\r\n        exit(0);\r\n    }\r\n\r\n进程控制示例：\r\n\r\n    #include \"apue.h\"\r\n    #include \"sys/wait.h\"\r\n    \r\n    int main(void){\r\n        char buff[MAXLINE];\r\n        pid_t pid;\r\n        int status;\r\n    \r\n        printf(\"%%\");\r\n    \r\n        while(fgets(buff, MAXLINE, stdin) != NULL){\r\n            if(buff[strlen(buff) - 1] == \'\\n\'){\r\n                buff[strlen(buff) - 1] = 0;\r\n            }\r\n    \r\n            if((pid = fork()) < 0){\r\n                err_sys(\"fork error\");\r\n            }\r\n    \r\n            if(pid == 0){\r\n                execlp(buff, buff, (char *)0);\r\n                err_ret(\"could\'t execute: %s\", buff);\r\n                exit(127);\r\n            }\r\n    \r\n            if((pid = waitpid(pid, &status, 0)) < 0){\r\n                err_sys(\"waitpid error \");\r\n            }\r\n            printf(\"%%\");\r\n        }\r\n        exit(0);\r\n    }\r\n\r\n1.7、\r\n在程序出现错误的时候，unix会将错误记在全局变量errno里面。\r\nerrno的定义为有两种，普通系统： \r\n\r\n    extern int errno;\r\n\r\n多线程系统：\r\n\r\n    extern int *__errno_location(void); \r\n    #define errno (*__errno_location())\r\n\r\n实例：\r\n\r\n    #include \"apue.h\"\r\n    #include \"errno.h\"\r\n    \r\n    int main(int argc, char * argv[]){\r\n        fprintf(stderr, \"EACCES: %s\\n\", strerror(EACCES));\r\n        errno = ENOENT;\r\n        perror(argv[0]);\r\n        exit(0);\r\n    \r\n    }\r\n\r\n运行结果：\r\n\r\n    EACCES: Permission denied\r\n    ./a.out: No such file or directory\r\n\r\n其中：\r\nfprintf是将打印结果输入到标准错误输出。\r\nstrerror是将错误码转换成错误信息。\r\nperror是将上次产生的错误信息转换成错误信息打印出来，如果传参数（比如本实例的argv[1]，也就是./a.out当前执行程序），将会通过冒号分隔传进来的字符串和错误信息输出到标准错误输出。\r\n\r\n1.8、\r\n1、每个用户都有一个用户id，一个组id。\r\n2、root用户的用户id和组id都是0.\r\n3、通过getuid()获得用户id，通过getgid()获得用户id。\r\n4、每个用户可以属于多个组，也就是说每个用户可以有多个附加组。\r\n5、用户id和组id是一个32位的整型，文件属于哪个用户或者组是通过存储着两个整型来标识的。存储整型而不是字符串可以更高效。\r\n实例程序：\r\n\r\n    #include \"apue.h\"\r\n    int main(void){\r\n        printf(\"uid: %d, gid: %d\\n\",getuid(), getgid());\r\n        exit(0);\r\n    }\r\n\r\n1.9、\r\n信号：Linux通知进程发生某种情况的一种机制。\r\n进程可以接收信号、处理信号或者发送信号。\r\n对于处理信号：可以不处理、按照操作系统的默认处理方法处理、自定义方法处理。\r\n实例程序：\r\n\r\n    #include \"apue.h\"\r\n    #include \"sys/wait.h\"\r\n    static void sig_int(int);\r\n    \r\n    int main(void){\r\n        char buff[MAXLINE];\r\n        pid_t pid;\r\n        int status;\r\n    \r\n        if(signal(SIGINT, sig_int) == SIG_ERR){\r\n            err_sys(\"signal error!\");\r\n        }\r\n    \r\n        printf(\"%%\");\r\n    \r\n        while(fgets(buff, MAXLINE, stdin) != NULL){\r\n            if(buff[strlen(buff) - 1] == \'\\n\'){\r\n                buff[strlen(buff) - 1] = 0;\r\n            }\r\n    \r\n            if((pid = fork()) < 0){\r\n                err_sys(\"fork error\");\r\n            }\r\n    \r\n            if(pid == 0){\r\n                execlp(buff, buff, (char *)0);\r\n                err_ret(\"could\'t execute: %s\", buff);\r\n                exit(127);\r\n            }\r\n    \r\n            if((pid = waitpid(pid, &status, 0)) < 0){\r\n                err_sys(\"waitpid error \");\r\n            }\r\n            printf(\"%%\");\r\n        }\r\n        exit(0);\r\n    }\r\n    \r\n    \r\n    void sig_int(int signo){\r\n        printf(\"interrupt\\n %%\");\r\n    }\r\n\r\n运行结果：\r\n\r\n    [root@***c1]# ./a.out\r\n    %ls\r\n    1.4.1.c  1.5.1.c  1.5.2.c  1.6.1.c  1.6.2.c  1.7.1.c  1.8.1.c  1.9.1.c	a.out  ls  test.log\r\n    %whoama\r\n    could\'t execute: whoama: No such file or directory\r\n    %whoami\r\n    root\r\n    %^Cinterrupt\r\n\r\n1.10、\r\n1、unix有两种时间，一种是时间戳，一种是进程的执行时间，其中进程的执行时间又分为：clock time, user cpu time, system cpu time。\r\n2、可以通过time -p your command 来查看进程执行的时间。\r\n示例：\r\n\r\n    time -p grep -rn \"un\" . > /dev/null\r\n    real 0.42\r\n    user 0.31\r\n    sys 0.10\r\n\r\nreal:从开始到结束的时间\r\nuser：用户态时间\r\nsys：核心态时间\r\n\r\n1.11\r\n本节主要讲了系统调用和库函数的区别，根据我的理解，总结如下：\r\n1、系统调用介于内核空间和用户空间之间，而库函数属于用户空间。库函数封装了系统调用共用户程序使用。\r\n2、库函数更丰富易用，系统调用函数更精简\r\n![系统调用和c库函数的区别][7]\r\n\r\n\r\n  [7]: http://7vzu8r.com1.z0.glb.clouddn.com/unix_programe_1.12.jpg\r\n  [1]: http://7vzu8r.com1.z0.glb.clouddn.com/unix_programe_unix%20architecture.jpg\r\n  [2]: http://blog.sae.sina.com.cn/archives/2200\r\n  [3]: http://www.cnblogs.com/viviwind/archive/2012/09/22/2698450.html\r\n  [4]: http://blog.sina.com.cn/s/blog_94977c890102vdms.html\r\n  [5]: http://www.shazidoubing.com/cplus/639.html\r\n  [6]: http://blog.csdn.net/victoryckl/article/details/8632054',0,1,NULL,'post','publish',NULL,0,'1','1','1',0);
/*!40000 ALTER TABLE `te_contents` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `te_fields`
--

DROP TABLE IF EXISTS `te_fields`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `te_fields` (
  `cid` int(10) unsigned NOT NULL,
  `name` varchar(200) NOT NULL,
  `type` varchar(8) DEFAULT 'str',
  `str_value` text,
  `int_value` int(10) DEFAULT '0',
  `float_value` float DEFAULT '0',
  PRIMARY KEY (`cid`,`name`),
  KEY `int_value` (`int_value`),
  KEY `float_value` (`float_value`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `te_fields`
--

LOCK TABLES `te_fields` WRITE;
/*!40000 ALTER TABLE `te_fields` DISABLE KEYS */;
/*!40000 ALTER TABLE `te_fields` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `te_metas`
--

DROP TABLE IF EXISTS `te_metas`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `te_metas` (
  `mid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `type` varchar(32) NOT NULL,
  `description` varchar(200) DEFAULT NULL,
  `count` int(10) unsigned DEFAULT '0',
  `order` int(10) unsigned DEFAULT '0',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`mid`),
  KEY `slug` (`slug`)
) ENGINE=MyISAM AUTO_INCREMENT=39 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `te_metas`
--

LOCK TABLES `te_metas` WRITE;
/*!40000 ALTER TABLE `te_metas` DISABLE KEYS */;
INSERT INTO `te_metas` VALUES (1,'闲说','闲说','category','闲说',5,1,0),(2,'php','php','category',NULL,5,2,0),(3,'php-fpm','php-fpm','category',NULL,5,1,2),(4,'php-fpm','php-fpm','tag',NULL,2,0,0),(5,'子进程最大服务次数','子进程最大服务次数','tag',NULL,1,0,0),(6,'pm.max_requests','pm-max_requests','tag',NULL,1,0,0),(7,'总结','总结','tag',NULL,0,0,0),(8,'php内核','php内核','category','php内核',4,2,2),(10,'javascript','js','category',NULL,1,3,0),(11,'配置','配置','tag',NULL,1,0,0),(12,'nodejs','nodejs','tag',NULL,1,0,0),(13,'编译安装','编译安装','tag',NULL,1,0,0),(14,'NodeJs','NodeJs','category',NULL,2,4,0),(15,'golang','go','category',NULL,0,5,0),(16,'php多线程','php多线程','tag',NULL,1,0,0),(17,'zts','zts','tag',NULL,1,0,0),(18,'linux','linux','category',NULL,7,6,0),(19,'进程通信','进程通信','tag',NULL,1,0,0),(20,'信号','信号','tag',NULL,1,0,0),(21,'epoll','epoll','tag',NULL,1,0,0),(22,'网络','网络','tag',NULL,1,0,0),(23,'mongodb','mongodb','category',NULL,2,7,0),(24,'转载','转载','category',NULL,1,8,0),(25,'翻译','翻译','category',NULL,0,9,0),(26,'mongodb','mongodb','tag',NULL,1,0,0),(27,'转录','转录','tag',NULL,1,0,0),(28,'其它','其它','category',NULL,1,10,0),(29,'shell','shell','tag',NULL,1,0,0),(30,'数组','数组','tag',NULL,1,0,0),(31,'系统与架构','系统与架构','category','系统与架构',4,11,0),(32,'unix环境高级编程读书笔记','up_reading','category',NULL,1,12,0),(34,'memcache','mc','category',NULL,1,1,36),(36,'数据库','db','category',NULL,0,14,0),(37,'nginx','nginx','category',NULL,2,15,0),(38,'大数据','bigdata','category',NULL,1,16,0);
/*!40000 ALTER TABLE `te_metas` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `te_options`
--

DROP TABLE IF EXISTS `te_options`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `te_options` (
  `name` varchar(32) NOT NULL,
  `user` int(10) unsigned NOT NULL DEFAULT '0',
  `value` text,
  PRIMARY KEY (`name`,`user`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `te_options`
--

LOCK TABLES `te_options` WRITE;
/*!40000 ALTER TABLE `te_options` DISABLE KEYS */;
INSERT INTO `te_options` VALUES ('theme',0,'navy'),('timezone',0,'28800'),('lang',0,NULL),('charset',0,'UTF-8'),('contentType',0,'text/html'),('gzip',0,'0'),('generator',0,'Typecho 1.0/14.10.10'),('title',0,'少说绝对'),('description',0,'其实，本blog大部分内容都是 在瞎扯'),('keywords',0,'blog'),('rewrite',0,'0'),('frontPage',0,'recent'),('frontArchive',0,'0'),('commentsRequireMail',0,'1'),('commentsWhitelist',0,'0'),('commentsRequireURL',0,'0'),('commentsRequireModeration',0,'0'),('plugins',0,'a:2:{s:9:\"activated\";a:1:{s:18:\"GoogleCodePrettify\";a:1:{s:7:\"handles\";a:2:{s:21:\"Widget_Archive:header\";a:1:{i:0;a:2:{i:0;s:25:\"GoogleCodePrettify_Plugin\";i:1;s:6:\"header\";}}s:21:\"Widget_Archive:footer\";a:1:{i:0;a:2:{i:0;s:25:\"GoogleCodePrettify_Plugin\";i:1;s:6:\"footer\";}}}}}s:7:\"handles\";a:2:{s:21:\"Widget_Archive:header\";a:1:{s:5:\"0.001\";a:2:{i:0;s:25:\"GoogleCodePrettify_Plugin\";i:1;s:6:\"header\";}}s:21:\"Widget_Archive:footer\";a:1:{s:5:\"0.001\";a:2:{i:0;s:25:\"GoogleCodePrettify_Plugin\";i:1;s:6:\"footer\";}}}}'),('commentDateFormat',0,'F jS, Y \\a\\t h:i a'),('siteUrl',0,'http://blog.dufei.cc'),('defaultCategory',0,'1'),('allowRegister',0,'1'),('defaultAllowComment',0,'1'),('defaultAllowPing',0,'1'),('defaultAllowFeed',0,'1'),('pageSize',0,'5'),('postsListSize',0,'10'),('commentsListSize',0,'10'),('commentsHTMLTagAllowed',0,NULL),('postDateFormat',0,'Y-m-d'),('feedFullText',0,'1'),('editorSize',0,'350'),('autoSave',0,'0'),('markdown',0,'1'),('commentsMaxNestingLevels',0,'5'),('commentsPostTimeout',0,'2592000'),('commentsUrlNofollow',0,'1'),('commentsShowUrl',0,'1'),('commentsMarkdown',0,'0'),('commentsPageBreak',0,'0'),('commentsThreaded',0,'1'),('commentsPageSize',0,'20'),('commentsPageDisplay',0,'last'),('commentsOrder',0,'ASC'),('commentsCheckReferer',0,'1'),('commentsAutoClose',0,'0'),('commentsPostIntervalEnable',0,'1'),('commentsPostInterval',0,'60'),('commentsShowCommentOnly',0,'0'),('commentsAvatar',0,'1'),('commentsAvatarRating',0,'G'),('commentsAntiSpam',0,'1'),('routingTable',0,'a:26:{i:0;a:25:{s:5:\"index\";a:6:{s:3:\"url\";s:1:\"/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:8:\"|^[/]?$|\";s:6:\"format\";s:1:\"/\";s:6:\"params\";a:0:{}}s:7:\"archive\";a:6:{s:3:\"url\";s:6:\"/blog/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:13:\"|^/blog[/]?$|\";s:6:\"format\";s:6:\"/blog/\";s:6:\"params\";a:0:{}}s:2:\"do\";a:6:{s:3:\"url\";s:22:\"/action/[action:alpha]\";s:6:\"widget\";s:9:\"Widget_Do\";s:6:\"action\";s:6:\"action\";s:4:\"regx\";s:32:\"|^/action/([_0-9a-zA-Z-]+)[/]?$|\";s:6:\"format\";s:10:\"/action/%s\";s:6:\"params\";a:1:{i:0;s:6:\"action\";}}s:4:\"post\";a:6:{s:3:\"url\";s:24:\"/archives/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:26:\"|^/archives/([0-9]+)[/]?$|\";s:6:\"format\";s:13:\"/archives/%s/\";s:6:\"params\";a:1:{i:0;s:3:\"cid\";}}s:10:\"attachment\";a:6:{s:3:\"url\";s:26:\"/attachment/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:28:\"|^/attachment/([0-9]+)[/]?$|\";s:6:\"format\";s:15:\"/attachment/%s/\";s:6:\"params\";a:1:{i:0;s:3:\"cid\";}}s:8:\"category\";a:6:{s:3:\"url\";s:17:\"/category/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:25:\"|^/category/([^/]+)[/]?$|\";s:6:\"format\";s:13:\"/category/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}s:3:\"tag\";a:6:{s:3:\"url\";s:12:\"/tag/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:20:\"|^/tag/([^/]+)[/]?$|\";s:6:\"format\";s:8:\"/tag/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}s:6:\"author\";a:6:{s:3:\"url\";s:22:\"/author/[uid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:24:\"|^/author/([0-9]+)[/]?$|\";s:6:\"format\";s:11:\"/author/%s/\";s:6:\"params\";a:1:{i:0;s:3:\"uid\";}}s:6:\"search\";a:6:{s:3:\"url\";s:19:\"/search/[keywords]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:23:\"|^/search/([^/]+)[/]?$|\";s:6:\"format\";s:11:\"/search/%s/\";s:6:\"params\";a:1:{i:0;s:8:\"keywords\";}}s:10:\"index_page\";a:6:{s:3:\"url\";s:21:\"/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:22:\"|^/page/([0-9]+)[/]?$|\";s:6:\"format\";s:9:\"/page/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"page\";}}s:12:\"archive_page\";a:6:{s:3:\"url\";s:26:\"/blog/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:27:\"|^/blog/page/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/blog/page/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"page\";}}s:13:\"category_page\";a:6:{s:3:\"url\";s:32:\"/category/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:34:\"|^/category/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:16:\"/category/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"slug\";i:1;s:4:\"page\";}}s:8:\"tag_page\";a:6:{s:3:\"url\";s:27:\"/tag/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:29:\"|^/tag/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:11:\"/tag/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"slug\";i:1;s:4:\"page\";}}s:11:\"author_page\";a:6:{s:3:\"url\";s:37:\"/author/[uid:digital]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:33:\"|^/author/([0-9]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/author/%s/%s/\";s:6:\"params\";a:2:{i:0;s:3:\"uid\";i:1;s:4:\"page\";}}s:11:\"search_page\";a:6:{s:3:\"url\";s:34:\"/search/[keywords]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:32:\"|^/search/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/search/%s/%s/\";s:6:\"params\";a:2:{i:0;s:8:\"keywords\";i:1;s:4:\"page\";}}s:12:\"archive_year\";a:6:{s:3:\"url\";s:18:\"/[year:digital:4]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:19:\"|^/([0-9]{4})[/]?$|\";s:6:\"format\";s:4:\"/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"year\";}}s:13:\"archive_month\";a:6:{s:3:\"url\";s:36:\"/[year:digital:4]/[month:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:30:\"|^/([0-9]{4})/([0-9]{2})[/]?$|\";s:6:\"format\";s:7:\"/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"year\";i:1;s:5:\"month\";}}s:11:\"archive_day\";a:6:{s:3:\"url\";s:52:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:41:\"|^/([0-9]{4})/([0-9]{2})/([0-9]{2})[/]?$|\";s:6:\"format\";s:10:\"/%s/%s/%s/\";s:6:\"params\";a:3:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:3:\"day\";}}s:17:\"archive_year_page\";a:6:{s:3:\"url\";s:38:\"/[year:digital:4]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:33:\"|^/([0-9]{4})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:12:\"/%s/page/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"year\";i:1;s:4:\"page\";}}s:18:\"archive_month_page\";a:6:{s:3:\"url\";s:56:\"/[year:digital:4]/[month:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:44:\"|^/([0-9]{4})/([0-9]{2})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:15:\"/%s/%s/page/%s/\";s:6:\"params\";a:3:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:4:\"page\";}}s:16:\"archive_day_page\";a:6:{s:3:\"url\";s:72:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:55:\"|^/([0-9]{4})/([0-9]{2})/([0-9]{2})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:18:\"/%s/%s/%s/page/%s/\";s:6:\"params\";a:4:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:3:\"day\";i:3;s:4:\"page\";}}s:12:\"comment_page\";a:6:{s:3:\"url\";s:53:\"[permalink:string]/comment-page-[commentPage:digital]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:36:\"|^(.+)/comment\\-page\\-([0-9]+)[/]?$|\";s:6:\"format\";s:18:\"%s/comment-page-%s\";s:6:\"params\";a:2:{i:0;s:9:\"permalink\";i:1;s:11:\"commentPage\";}}s:4:\"feed\";a:6:{s:3:\"url\";s:20:\"/feed[feed:string:0]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:4:\"feed\";s:4:\"regx\";s:17:\"|^/feed(.*)[/]?$|\";s:6:\"format\";s:7:\"/feed%s\";s:6:\"params\";a:1:{i:0;s:4:\"feed\";}}s:8:\"feedback\";a:6:{s:3:\"url\";s:31:\"[permalink:string]/[type:alpha]\";s:6:\"widget\";s:15:\"Widget_Feedback\";s:6:\"action\";s:6:\"action\";s:4:\"regx\";s:29:\"|^(.+)/([_0-9a-zA-Z-]+)[/]?$|\";s:6:\"format\";s:5:\"%s/%s\";s:6:\"params\";a:2:{i:0;s:9:\"permalink\";i:1;s:4:\"type\";}}s:4:\"page\";a:6:{s:3:\"url\";s:12:\"/[slug].html\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:22:\"|^/([^/]+)\\.html[/]?$|\";s:6:\"format\";s:8:\"/%s.html\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}}s:5:\"index\";a:3:{s:3:\"url\";s:1:\"/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:7:\"archive\";a:3:{s:3:\"url\";s:6:\"/blog/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:2:\"do\";a:3:{s:3:\"url\";s:22:\"/action/[action:alpha]\";s:6:\"widget\";s:9:\"Widget_Do\";s:6:\"action\";s:6:\"action\";}s:4:\"post\";a:3:{s:3:\"url\";s:24:\"/archives/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:10:\"attachment\";a:3:{s:3:\"url\";s:26:\"/attachment/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:8:\"category\";a:3:{s:3:\"url\";s:17:\"/category/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:3:\"tag\";a:3:{s:3:\"url\";s:12:\"/tag/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:6:\"author\";a:3:{s:3:\"url\";s:22:\"/author/[uid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:6:\"search\";a:3:{s:3:\"url\";s:19:\"/search/[keywords]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:10:\"index_page\";a:3:{s:3:\"url\";s:21:\"/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"archive_page\";a:3:{s:3:\"url\";s:26:\"/blog/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:13:\"category_page\";a:3:{s:3:\"url\";s:32:\"/category/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:8:\"tag_page\";a:3:{s:3:\"url\";s:27:\"/tag/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"author_page\";a:3:{s:3:\"url\";s:37:\"/author/[uid:digital]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"search_page\";a:3:{s:3:\"url\";s:34:\"/search/[keywords]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"archive_year\";a:3:{s:3:\"url\";s:18:\"/[year:digital:4]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:13:\"archive_month\";a:3:{s:3:\"url\";s:36:\"/[year:digital:4]/[month:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"archive_day\";a:3:{s:3:\"url\";s:52:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:17:\"archive_year_page\";a:3:{s:3:\"url\";s:38:\"/[year:digital:4]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:18:\"archive_month_page\";a:3:{s:3:\"url\";s:56:\"/[year:digital:4]/[month:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:16:\"archive_day_page\";a:3:{s:3:\"url\";s:72:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"comment_page\";a:3:{s:3:\"url\";s:53:\"[permalink:string]/comment-page-[commentPage:digital]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:4:\"feed\";a:3:{s:3:\"url\";s:20:\"/feed[feed:string:0]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:4:\"feed\";}s:8:\"feedback\";a:3:{s:3:\"url\";s:31:\"[permalink:string]/[type:alpha]\";s:6:\"widget\";s:15:\"Widget_Feedback\";s:6:\"action\";s:6:\"action\";}s:4:\"page\";a:3:{s:3:\"url\";s:12:\"/[slug].html\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}}'),('actionTable',0,'a:0:{}'),('panelTable',0,'a:0:{}'),('attachmentTypes',0,'@image@'),('secret',0,'kw!rYhnbCZeeBl(dGW)k7IA0BJhv)28j'),('autoSave',1,'1'),('markdown',1,'1'),('defaultAllowComment',1,'1'),('defaultAllowPing',1,'1'),('defaultAllowFeed',1,'1'),('plugin:GoogleCodePrettify',0,'a:2:{s:4:\"type\";s:6:\"desert\";s:6:\"custom\";s:0:\"\";}'),('theme:navy',0,'a:3:{s:13:\"navy_gravatar\";s:17:\"dufei05@gmail.com\";s:9:\"navy_tips\";s:12:\"少说绝对\";s:12:\"sidebarBlock\";a:3:{i:0;s:15:\"ShowRecentPosts\";i:1;s:12:\"ShowCategory\";i:2;s:11:\"ShowArchive\";}}');
/*!40000 ALTER TABLE `te_options` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `te_relationships`
--

DROP TABLE IF EXISTS `te_relationships`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `te_relationships` (
  `cid` int(10) unsigned NOT NULL,
  `mid` int(10) unsigned NOT NULL,
  PRIMARY KEY (`cid`,`mid`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `te_relationships`
--

LOCK TABLES `te_relationships` WRITE;
/*!40000 ALTER TABLE `te_relationships` DISABLE KEYS */;
INSERT INTO `te_relationships` VALUES (3,1),(4,3),(4,4),(4,5),(4,6),(5,1),(5,7),(8,10),(8,14),(10,3),(10,4),(10,11),(11,12),(11,13),(11,14),(12,1),(13,3),(13,8),(15,18),(15,21),(15,22),(18,18),(18,19),(18,20),(19,8),(19,16),(19,17),(20,18),(21,2),(21,3),(22,2),(22,3),(22,8),(22,18),(25,23),(27,23),(27,24),(27,26),(27,27),(28,28),(34,1),(35,2),(37,38),(38,1),(40,1),(41,1),(42,18),(42,29),(42,30),(43,1),(46,37),(48,2),(74,31),(83,34),(100,18),(114,31),(117,31),(166,2),(166,8),(173,18),(173,37),(188,32),(193,31);
/*!40000 ALTER TABLE `te_relationships` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `te_users`
--

DROP TABLE IF EXISTS `te_users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `te_users` (
  `uid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(32) DEFAULT NULL,
  `password` varchar(64) DEFAULT NULL,
  `mail` varchar(200) DEFAULT NULL,
  `url` varchar(200) DEFAULT NULL,
  `screenName` varchar(32) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `activated` int(10) unsigned DEFAULT '0',
  `logged` int(10) unsigned DEFAULT '0',
  `group` varchar(16) DEFAULT 'visitor',
  `authCode` varchar(64) DEFAULT NULL,
  PRIMARY KEY (`uid`),
  UNIQUE KEY `name` (`name`),
  UNIQUE KEY `mail` (`mail`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `te_users`
--

LOCK TABLES `te_users` WRITE;
/*!40000 ALTER TABLE `te_users` DISABLE KEYS */;
INSERT INTO `te_users` VALUES (1,'dufei','$P$BIm3XRGy96LVfDgXR.V7LYs4HjDSbT/','fffddgx1@sina.com','http://blog.justoffline.com/','dufei',1425089019,1448343627,1448302109,'administrator','62b8abd77c6e669847f7f6c17e3fc29f');
/*!40000 ALTER TABLE `te_users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2015-11-24 23:41:45
